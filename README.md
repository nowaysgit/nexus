# Nexus - AI Character Chat Bot

Проект представляет собой платформу для создания и взаимодействия с AI-персонажами через Telegram. Персонажи имеют реалистичную систему потребностей, мотиваций и действий.

## Особенности

- **Реалистичные характеры персонажей** - каждый персонаж имеет свои потребности, мотивации и эмоциональные состояния
- **Динамическое поведение** - персонажи могут выполнять различные действия, отражающие их текущее состояние
- **Интеграция с Telegram** - взаимодействие с персонажами через популярный мессенджер
- **Система памяти** - персонажи запоминают значимые события и сообщения пользователей
- **Нейросетевой анализ** - использование OpenAI для анализа сообщений пользователя и генерации ответов

## Технический стек

- **Backend**: NestJS, TypeScript
- **База данных**: PostgreSQL (для продакшена), SQLite (для тестирования)
- **ORM**: TypeORM
- **API**: OpenAI API, Llama API
- **Интеграция**: Telegram Bot API

## Установка и запуск

### Предварительные требования

- Node.js (>= 16.x)
- npm (>= 8.x) или yarn (рекомендуется)
- PostgreSQL (>= 14.x)

### Шаги по установке

1. Клонировать репозиторий:
   ```bash
   git clone https://github.com/yourusername/nexus.git
   cd nexus
   ```

2. Установить зависимости:
   ```bash
   yarn install
   ```

3. Настроить переменные окружения:
   ```bash
   cp .env.example .env
   ```
   Отредактировать `.env` файл, добавив необходимые ключи API и настройки.

4. Создать базу данных в PostgreSQL:
   ```bash
   createdb nexus
   ```

5. Запустить приложение:
   ```bash
   yarn run start:dev
   ```

## Структура проекта

- `src/` - исходный код
  - `character/` - модуль персонажей
    - `entities/` - сущности базы данных
    - `services/` - сервисы для работы с персонажами
    - `controllers/` - контроллеры API
    - `interfaces/` - интерфейсы и типы
    - `repositories/` - репозитории для работы с базой данных
    - `enums/` - перечисления
  - `telegram/` - модуль интеграции с Telegram
  - `llm/` - модуль работы с языковыми моделями (OpenAI, Llama)
  - `common/` - общие утилиты и конфигурация
  - `dialog/` - модуль диалогов
  - `user/` - модуль пользователей
  - `monitoring/` - модуль мониторинга и метрик
  - `logging/` - модуль логирования
  - `cache/` - модуль кэширования
  - `message-queue/` - модуль очереди сообщений
  - `prompt-template/` - модуль шаблонов промптов
- `lib/` - библиотеки
  - `tester/` - утилиты для тестирования
    - `fixtures/` - генераторы тестовых данных
    - `mocks/` - моки для тестирования
    - `utils/` - утилиты для тестирования
    - `docs/` - документация по тестированию
- `test/` - тесты
  - `character/` - тесты для модуля персонажей
  - `dialog/` - тесты для модуля диалогов
  - `integration/` - интеграционные тесты
  - `utils/` - тесты для утилит

## Настройка конфигурации

В проекте реализована система конфигурации, позволяющая настраивать различные параметры через переменные окружения:

- **Основные настройки**: порт, окружение, уровень логирования
- **База данных**: хост, порт, имя пользователя, пароль
- **OpenAI API**: ключ API, модель, температура
- **Telegram**: токен бота, webhook URL, ID администраторов
- **Персонажи**: интервалы обновления, настройки потребностей, действий и памяти
- **CORS**: настройка разрешенных источников для API запросов (CORS_ORIGIN)

## Оптимизация работы с LLM API

В проекте реализованы механизмы для оптимизации взаимодействия с языковыми моделями (LLM):

### Кэширование запросов

Сервис `CacheService` предоставляет функционал для кэширования запросов к API:
- Снижение количества запросов за счет сохранения ответов для идентичных сообщений
- Экономия токенов и снижение расходов на API
- Ускорение работы приложения за счет мгновенного получения ответов из кэша
- Настраиваемое время жизни кэшированных ответов (TTL)
- Статистика использования кэша (количество попаданий, промахов)

Основные методы сервиса:
- `get<T>(key)` - получение ответа из кэша
- `set<T>(key, value, ttl)` - сохранение ответа в кэш
- `createMessagesHash(messages)` - создание хэша для идентификации сообщений

### Шаблоны промптов

Система шаблонов промптов позволяет управлять подготовкой запросов к LLM API:
- Централизованное хранение шаблонов для различных типов запросов
- Подстановка параметров в шаблоны с использованием плейсхолдеров
- Настройка рекомендуемых параметров генерации (температура, количество токенов)
- Систематизация шаблонов по категориям

Реализовано через:
- `PromptTemplateService` - сервис для работы с шаблонами
- Категории шаблонов:
  - `CharacterResponsePrompts` - шаблоны для генерации ответов персонажей
  - `MessageAnalysisPrompts` - шаблоны для анализа сообщений
  - `ActionPrompts` - шаблоны для генерации действий персонажей

Использование:
```typescript
// Пример использования шаблонов
const response = await promptTemplateService.createPrompt('character-response-basic', {
  character,
  userMessage,
  emotionalState,
  dialogHistory
});
```

## Совместимость с SQLite

Проект поддерживает две базы данных:
- **PostgreSQL** - основная база данных для продакшена
- **SQLite** - база данных для тестирования

Для обеспечения совместимости между PostgreSQL и SQLite реализованы следующие механизмы:

### Адаптация SQL-запросов

Утилита `DbCompatibilityUtil` адаптирует SQL-запросы для работы с SQLite:
- Замена функций PostgreSQL на эквиваленты SQLite
- Адаптация синтаксиса INTERVAL
- Преобразование функции CONCAT в оператор ||
- Обработка специфичных для PostgreSQL функций

### Преобразование типов

Для корректной работы с разными типами ID в PostgreSQL и SQLite:
- Утилита `IdAdapter` для преобразования между string и number
- Проверка типов при выполнении запросов
- Автоматическое преобразование UUID в строки

### Обработка соединений

Для предотвращения ошибок с соединениями:
- Проверка наличия метода `query` в `queryRunner.manager`
- Добавление прокси-методов при необходимости
- Автоматическое восстановление соединений

## Тестирование

### Запуск тестов

#### С использованием PostgreSQL

1. **Запустите тестовую базу данных:**
   ```bash
   docker compose -f docker-compose.test.yml up -d
   ```

2. **Запустите интеграционные тесты:**
   ```bash
   yarn test:integration
   ```

3. **Запуск конкретного теста:**
   ```bash
   yarn test:integration -- --testNamePattern="название теста"
   ```

4. **Запуск всех тестов:**
   ```bash
   yarn test:all
   ```

5. **Остановка тестовых сервисов:**
   ```bash
   docker compose -f docker-compose.test.yml down
   ```

#### С использованием SQLite (без Docker)

Для запуска тестов без необходимости запуска Docker контейнеров:

1. **Запуск всех тестов с SQLite:**
   ```bash
   USE_SQLITE=true yarn test:all
   ```

2. **Запуск интеграционных тестов с SQLite:**
   ```bash
   USE_SQLITE=true yarn test:integration
   ```

3. **Запуск конкретного теста с SQLite:**
   ```bash
   USE_SQLITE=true yarn test test/path/to/test.ts
   ```

### Типы тестов

- **Unit тесты** - используют SQLite в памяти: `yarn test`
- **Интеграционные тесты** - могут использовать PostgreSQL или SQLite: `yarn test:integration`
- **Параллельные тесты** - запуск тестов в нескольких потоках: `yarn test:parallel`
- **E2E тесты** - тестирование всего приложения: `yarn test:e2e`

### Оптимизация тестирования

Проект включает набор утилит для оптимизации тестов:

#### Управление соединениями с базой данных

`DbConnectionManager` помогает избежать проблем с "too many clients" при параллельном выполнении тестов:
- Автоматическое отслеживание и закрытие соединений
- Оптимизация использования соединений
- Предотвращение утечек соединений

#### Оптимизация очистки базы данных

`DbCleanupUtil` обеспечивает быструю очистку базы данных между тестами:
- Использование TRUNCATE CASCADE вместо DELETE
- Очистка только необходимых таблиц
- Создание временных схем для изоляции тестов

#### Оптимизация работы с базой данных

`DbOptimizationUtil` предоставляет методы для оптимизации запросов:
- Кеширование результатов запросов
- Выполнение запросов в транзакции
- Пакетная вставка и обновление данных
- Оптимизированные репозитории с кешированием

#### Совместимость с разными базами данных

`DbCompatibilityUtil` обеспечивает совместимость тестов с PostgreSQL и SQLite:
- Адаптация SQL запросов
- Совместимые методы для работы с датами, строками и таблицами
- Адаптация репозиториев и EntityManager

#### Пакетное создание тестовых данных

`FixtureManager` предоставляет методы для быстрого создания тестовых данных:
- Создание нескольких сущностей за один запрос
- Создание связанных сущностей (пользователь-персонаж-диалог)
- Создание полного набора тестовых данных для всего приложения
- Оптимизированная очистка базы данных

### Документация по тестированию

Подробная документация по использованию утилит для оптимизации тестов доступна в:
- `lib/tester/docs/test-optimization.md` - оптимизация тестов
- `lib/tester/docs/logging-mocks.md` - моки для логирования
- `lib/tester/README.md` - общая информация о тестовой инфраструктуре

### Конфигурация

- Тестовая конфигурация: `.env.test`
- Docker compose для тестов: `docker-compose.test.yml`
- Jest конфигурация: `jest.config.js` и `jest.integration.config.js`

### Известные проблемы и их решения

#### Проблема: queryRunner.manager.query is not a function

При использовании SQLite в тестах может возникнуть ошибка `queryRunner.manager.query is not a function`. Это происходит из-за отсутствия метода `query` в объекте `manager` при использовании SQLite.

**Решение:**
В текущей версии добавлена автоматическая проверка наличия метода `query` и его добавление при необходимости в `db-connection-checker.ts`. Если вы все еще сталкиваетесь с этой проблемой, используйте следующий подход:

```typescript
// Проверяем наличие метода query и добавляем его при необходимости
if (!queryRunner.manager.query) {
  queryRunner.manager.query = (...args) => queryRunner.query(...args);
}
```

#### Проблема: FOREIGN KEY constraint failed

При создании связанных сущностей в SQLite может возникнуть ошибка `FOREIGN KEY constraint failed`.

**Решение:**
Убедитесь, что вы создаете сущности в правильном порядке (сначала родительские, затем дочерние) и используете правильные ID. В `FixtureManager` добавлены проверки на существование связанных сущностей перед созданием новых.

#### Проблема: Несовместимость типов ID между PostgreSQL и SQLite

PostgreSQL и SQLite по-разному обрабатывают типы ID (UUID в PostgreSQL и строки/числа в SQLite).

**Решение:**
Используйте утилиту `IdAdapter` для преобразования ID между разными форматами:

```typescript
import { IdAdapter } from '../../lib/tester/utils/id-converter';

// Преобразование ID из строки в число (если необходимо)
const numericId = IdAdapter.toNumeric(stringId);

// Преобразование ID из числа в строку (если необходимо)
const stringId = IdAdapter.toString(numericId);
```

## Лицензия

MIT
