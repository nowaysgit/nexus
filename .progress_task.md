# Техническое задание на разработку системы интеллектуальных персонажей

## Введение

Настоящее техническое задание (ТЗ) описывает требования к разработке системы интеллектуальных персонажей, реализованной в виде Telegram-бота. Целью данной системы является создание реалистичных, автономных, эмоционально-поведенческих виртуальных персонажей, способных взаимодействовать с пользователями, развиваться и адаптироваться в процессе общения. Документ разработан в соответствии с методологией, предоставленной заказчиком, и служит основой для проектирования, разработки и тестирования программного обеспечения.

Система будет построена на базе технологий Node.js, NestJS и Telegraf, обеспечивая высокую производительность, модульность и масштабируемость. В рамках данного ТЗ будут детализированы функциональные и нефункциональные требования, архитектурные решения, структура базы данных, API, а также аспекты интеграции с внешними сервисами и поведенческой логики персонажей.

## 1. Анализ требований и формализация

### 1.1. Детализация пользовательских сценариев (Use Cases)

В данном разделе представлены основные пользовательские сценарии, описывающие взаимодействие пользователя с системой интеллектуальных персонажей. Каждый сценарий детализирует последовательность действий, ожидаемые результаты и возможные альтернативные потоки.

#### 1.1.1. Сценарий: Инициация диалога с персонажем

**Описание:** Пользователь начинает общение с интеллектуальным персонажем через Telegram.

**Акторы:** Пользователь, TelegramBot, Система интеллектуальных персонажей.

**Предусловия:** Пользователь имеет активный аккаунт в Telegram. Система интеллектуальных персонажей развернута и доступна.

**Основной поток:**
1. Пользователь открывает чат с Telegram-ботом.
2. Пользователь отправляет первое сообщение (например, приветствие или команду `/start`).
3. TelegramBot получает сообщение и передает его в Систему интеллектуальных персонажей.
4. Система интеллектуальных персонажей идентифицирует пользователя (или создает нового, если это первое взаимодействие).
5. Система интеллектуальных персонажей выбирает или инициализирует персонажа для взаимодействия с пользователем.
6. Персонаж генерирует ответ на основе своего текущего состояния, мотиваций и контекста диалога.
7. Система интеллектуальных персонажей отправляет ответ персонажа через TelegramBot пользователю.
8. Пользователь получает сообщение от персонажа.

**Альтернативные потоки:**
* **А1: Персонаж недоступен:** Если выбранный персонаж временно недоступен, система может предложить другого персонажа или уведомить пользователя о временных неполадках.
* **А2: Ошибка инициализации:** В случае ошибки при инициализации персонажа, система отправляет пользователю сообщение об ошибке и предлагает повторить попытку.

#### 1.1.2. Сценарий: Ведение диалога с персонажем

**Описание:** Пользователь продолжает общение с интеллектуальным персонажем.

**Акторы:** Пользователь, TelegramBot, Система интеллектуальных персонажей, LLM (Large Language Model).

**Предусловия:** Диалог с персонажем уже инициирован.

**Основной поток:**
1. Пользователь отправляет сообщение персонажу в Telegram.
2. TelegramBot получает сообщение и передает его в Систему интеллектуальных персонажей.
3. Система интеллектуальных персонажей анализирует сообщение пользователя, используя `MessageAnalysisService`.
4. Система интеллектуальных персонажей обновляет контекст диалога и состояние персонажа (эмоции, мотивации) на основе сообщения пользователя.
5. Система интеллектуальных персонажей формирует промпт для LLM, включая текущий контекст, память персонажа и его поведенческие параметры.
6. LLM генерирует ответ на основе промпта.
7. Система интеллектуальных персонажей получает ответ от LLM и, при необходимости, корректирует его в соответствии с поведенческой логикой персонажа.
8. Система интеллектуальных персонажей отправляет ответ персонажа через TelegramBot пользователю.
9. Пользователь получает сообщение от персонажа.

**Альтернативные потоки:**
* **А1: Непонимание запроса:** Если LLM или система не может адекватно обработать запрос пользователя, персонаж может запросить уточнение или переформулировать вопрос.
* **А2: Активация манипулятивной техники:** В зависимости от контекста и состояния персонажа, `ManipulationTechnique` может быть активирована, влияя на ответ персонажа.
* **А3: Обновление долгосрочной памяти:** Важные фрагменты диалога или новые сведения о пользователе могут быть сохранены в долгосрочной памяти персонажа.

#### 1.1.3. Сценарий: Персонаж проявляет инициативу

**Описание:** Интеллектуальный персонаж самостоятельно инициирует диалог или действие.

**Акторы:** Система интеллектуальных персонажей, TelegramBot, Пользователь.

**Предусловия:** Персонаж находится в активном состоянии. Пользователь доступен для получения сообщений.

**Основной поток:**
1. Система интеллектуальных персонажей определяет необходимость инициации действия (например, на основе внутренних мотиваций, запланированных событий или реакции на внешние триггеры).
2. Персонаж генерирует сообщение или действие.
3. Система интеллектуальных персонажей отправляет сообщение персонажа через TelegramBot пользователю.
4. Пользователь получает сообщение от персонажа.

**Альтернативные потоки:**
* **А1: Пользователь не отвечает:** Если пользователь не отвечает на инициативу персонажа в течение определенного времени, персонаж может предпринять повторную попытку или изменить свою стратегию.

#### 1.1.4. Сценарий: Изменение состояния персонажа

**Описание:** Внутренние параметры персонажа (мотивации, эмоции, потребности) изменяются в процессе взаимодействия или по времени.

**Акторы:** Система интеллектуальных персонажей.

**Предусловия:** Персонаж активен.

**Основной поток:**
1. Система интеллектуальных персонажей отслеживает внутренние и внешние события (например, сообщения пользователя, прошедшее время, выполнение или невыполнение потребностей).
2. `NeedsService`, `EmotionalStateService`, `MotivationService` пересчитывают соответствующие параметры персонажа.
3. Изменения сохраняются в базе данных.
4. Обновленное состояние персонажа влияет на его дальнейшее поведение и генерацию ответов.

**Альтернативные потоки:**
* **А1: Фрустрация персонажа:** Если потребности персонажа долго не удовлетворяются, может наступить состояние фрустрации, которое активирует специфические поведенческие реакции или автоматические события.

#### 1.1.5. Сценарий: Архивация и компрессия памяти

**Описание:** Система автоматически обрабатывает и сжимает долговременную память персонажа для оптимизации хранения и использования.

**Акторы:** Система интеллектуальных персонажей.

**Предусловия:** Накоплен достаточный объем диалоговых данных или контекста.

**Основной поток:**
1. Система интеллектуальных персонажей запускает процесс архивации/компрессии памяти (по расписанию или по достижении определенного объема).
2. `ContextCompressionService` применяет алгоритмы сжатия (например, map-reduce, выделение ключевых смыслов) к старым или менее важным фрагментам памяти.
3. Сжатые данные сохраняются, а исходные могут быть удалены или помечены как архивированные.
4. Сжатая память используется для формирования контекста в промптах LLM.

**Альтернативные потоки:**
* **А1: Ошибка компрессии:** В случае ошибки, система логирует проблему и может повторить попытку или пометить данные для ручной обработки.

### 1.2. Определение акторов

Взаимодействие в системе интеллектуальных персонажей осуществляется между следующими ключевыми акторами:

*   **Пользователь:** Человек, взаимодействующий с интеллектуальным персонажем через интерфейс Telegram. Отправляет сообщения, команды, получает ответы от персонажа.
*   **TelegramBot:** Программный интерфейс (API) Telegram, который обеспечивает прием сообщений от пользователей и отправку ответов от системы. Выступает в роли посредника между пользователем и Системой интеллектуальных персонажей.
*   **Система интеллектуальных персонажей:** Основное программное обеспечение, реализующее логику, поведение, память и взаимодействие персонажей. Включает в себя все backend-модули и сервисы (NestJS-приложение).
*   **LLM (Large Language Model):** Внешняя большая языковая модель (например, OpenAI GPT, Google Gemini), используемая для генерации естественного языка на основе сформированных промптов. Является ключевым компонентом для создания реалистичных диалогов.

### 1.3. Разделение требований

Требования к системе интеллектуальных персонажей разделены на функциональные, нефункциональные и ограничения.

#### 1.3.1. Функциональные требования

Функциональные требования описывают, что система должна делать.

*   **Управление персонажами:**
    *   Система должна позволять создавать, редактировать и удалять интеллектуальных персонажей.
    *   Каждый персонаж должен иметь настраиваемые параметры: имя, описание, начальные мотивации, эмоциональный профиль, поведенческие паттерны.
    *   Система должна поддерживать уникальные идентификаторы для каждого персонажа.
*   **Диалоговое взаимодействие:**
    *   Система должна обеспечивать двустороннее текстовое взаимодействие между пользователем и персонажем через Telegram.
    *   Персонаж должен генерировать релевантные и контекстуально осмысленные ответы на сообщения пользователя.
    *   Система должна поддерживать обработку команд Telegram (например, `/start`, `/help`).
    *   Персонаж должен уметь инициировать диалог или задавать вопросы пользователю.
*   **Управление памятью и контекстом:**
    *   Система должна хранить краткосрочную (текущий диалог) и долгосрочную память персонажа.
    *   Долгосрочная память должна включать историю взаимодействия с пользователем, ключевые события, факты и выводы о пользователе.
    *   Система должна автоматически сжимать и архивировать старые или менее важные фрагменты памяти для оптимизации хранения и скорости доступа.
    *   Система должна динамически формировать контекст для LLM-промптов на основе краткосрочной и долгосрочной памяти.
*   **Поведенческая логика персонажа:**
    *   Система должна моделировать внутренние состояния персонажа: потребности (`Needs`), мотивации (`Motivation`), эмоциональное состояние (`EmotionalState`).
    *   Поведение персонажа должно динамически изменяться в зависимости от его внутренних состояний и внешних стимулов.
    *   Система должна поддерживать активацию специфических поведенческих паттернов (например, фрустрация, радость, агрессия).
    *   Система должна позволять настраивать и расширять поведенческие алгоритмы.
*   **Интеграция с LLM:**
    *   Система должна взаимодействовать с внешней LLM для генерации текстовых ответов.
    *   Система должна формировать структурированные промпты для LLM, включающие контекст, роль персонажа, его текущее состояние и историю диалога.
    *   Система должна обрабатывать ответы от LLM, при необходимости корректируя их для соответствия поведенческой модели персонажа.
*   **Механизмы влияния и этики:**
    *   Система должна поддерживать набор техник влияния (`ManipulationTechnique`), которые персонаж может применять в диалоге.
    *   Система должна включать `MessageAnalysisService` для проверки этичности и безопасности генерируемых ответов и применяемых техник.
    *   Должна быть предусмотрена возможность логирования и аудита использования техник влияния.
    *   Должна быть возможность отключения или ограничения определенных техник влияния.
*   **Администрирование и мониторинг:**
    *   Система должна предоставлять средства для мониторинга активности персонажей и пользователей.
    *   Должна быть возможность просмотра логов и статистики взаимодействия.

#### 1.3.2. Нефункциональные требования

Нефункциональные требования описывают, как система должна работать.

*   **Производительность:**
    *   Время ответа персонажа на сообщение пользователя не должно превышать 2 секунд для 90% запросов.
    *   Система должна поддерживать одновременное взаимодействие с не менее чем 1000 активными пользователями без деградации производительности.
    *   Процессы архивации и компрессии памяти должны выполняться в фоновом режиме, не влияя на интерактивное взаимодействие.
*   **Надежность и отказоустойчивость:**
    *   Система должна быть устойчива к сбоям отдельных компонентов (например, временная недоступность LLM).
    *   Должен быть предусмотрен механизм повторных попыток для внешних запросов (к LLM, Telegram API).
    *   Данные о персонажах и диалогах должны быть персистентными и защищены от потери.
*   **Масштабируемость:**
    *   Архитектура системы должна позволять горизонтальное масштабирование backend-сервисов и базы данных для обработки растущей нагрузки.
    *   Должна быть возможность легкого добавления новых персонажей и расширения их поведенческой логики.
*   **Безопасность:**
    *   Все взаимодействия с внешними API (Telegram, LLM) должны осуществляться по защищенным протоколам (HTTPS).
    *   Данные пользователей и диалогов должны храниться в зашифрованном виде.
    *   Должна быть реализована защита от типичных веб-уязвимостей (SQL-инъекции, XSS, CSRF).
    *   Доступ к административным функциям должен быть строго ограничен и требовать аутентификации.
*   **Удобство сопровождения:**
    *   Код должен быть модульным, хорошо документированным и соответствовать стандартам кодирования NestJS.
    *   Должна быть предусмотрена система логирования для отладки и мониторинга.
    *   Развертывание системы должно быть автоматизировано (например, с использованием Docker).
*   **Конфиденциальность:**
    *   Система должна соответствовать требованиям по защите персональных данных (например, GDPR, если применимо).
    *   Данные пользователей должны быть анонимизированы или псевдонимизированы, где это возможно.

#### 1.3.3. Ограничения

Ограничения описывают факторы, которые влияют на разработку системы.

*   **Технологический стек:**
    *   Backend: Node.js, NestJS.
    *   Telegram-интеграция: Telegraf.
    *   База данных: Выбор будет сделан на этапе проектирования, но должна быть реляционной (например, PostgreSQL) или NoSQL (например, MongoDB) с учетом требований к масштабируемости и типу данных.
    *   LLM: Внешняя API-совместимая большая языковая модель (например, OpenAI API, Google Gemini API).
*   **Бюджет:** Ограниченность бюджета может влиять на выбор платных сервисов (LLM, хостинг) и объем функционала в первой версии.
*   **Сроки:** Сжатые сроки разработки могут потребовать приоритизации функционала и поэтапного внедрения.
*   **Производительность LLM:** Производительность системы напрямую зависит от скорости и доступности внешней LLM. Возможны задержки или сбои, не зависящие от backend-системы.
*   **Приватность:** Система не должна собирать или хранить избыточные персональные данные пользователей. Все данные должны использоваться исключительно для улучшения взаимодействия с персонажем.

### 1.4. Первая версия структуры ТЗ

Первая версия структуры технического задания будет включать следующие разделы, которые будут детализированы в последующих шагах:

1.  **Введение**
2.  **Анализ требований и формализация**
    *   2.1. Детализация пользовательских сценариев (Use Cases)
    *   2.2. Определение акторов
    *   2.3. Разделение требований (функциональные, нефункциональные, ограничения)
3.  **Архитектура Backend-системы**
    *   3.1. Структура модулей и сервисов
    *   3.2. Взаимодействие между сервисами
    *   3.3. Фоновые задачи, очереди, кэш
4.  **Проектирование базы данных**
    *   4.1. Сущности и их атрибуты
    *   4.2. ER-диаграмма и связи
    *   4.3. Поддержка историчности и версионирования
    *   4.4. Первичная и вторичная память
5.  **Проектирование API**
    *   5.1. Эндпоинты и методы
    *   5.2. Авторизация и валидация
    *   5.3. Спецификация OpenAPI/Swagger
6.  **Интеграция с TelegramBot**
    *   6.1. Настройка TelegramModule
    *   6.2. Обработка команд и состояний
    *   6.3. Генерация промптов для LLM
7.  **Поведенческая логика персонажа**
    *   7.1. Моделирование мотиваций и эмоций
    *   7.2. Влияние на поведение и генерацию промптов
    *   7.3. Автоматические события
8.  **Управление контекстом и памятью**
    *   8.1. Алгоритмы сжатия памяти
    *   8.2. Логика выдачи контекста в промпт
    *   8.3. Стратегии удаления памяти
9.  **Этика и механизмы влияния**
    *   9.1. Техники влияния и условия активации
    *   9.2. Ограничения и этические проверки
    *   9.3. Логирование и аудит
10. **Финальный этап: Консолидация ТЗ**
    *   10.1. Объединение всех частей
    *   10.2. Глобальная проверка и оценка уверенности
11. **Система тестирования**
    *   11.1. Структура каталогов и уровней тестов
    *   11.2. Инфраструктура тестирования (библиотека, фикстуры, моки)
    *   11.3. Метрики покрытия и автоматизация CI

---



## 2. Архитектура Backend-системы

### 2.1. Структура модулей и сервисов

#### AuthModule

**Описание**: Отвечает за аутентификацию и авторизацию пользователей. Включает сервисы для управления пользователями, сессиями и доступом.

**Путь**: `src/auth/`

**Контроллеры**:
*   `AuthController` (`src/auth/auth.controller.ts`): Обрабатывает запросы на регистрацию, вход, выход и обновление токенов.

**Сервисы**:
*   `AuthService` (`src/auth/auth.service.ts`): Основная бизнес-логика для аутентификации пользователей.
*   `JwtAuthService` (`src/auth/jwt-auth.service.ts`): Сервис для работы с JWT токенами (генерация, валидация).
*   `SessionService` (`src/auth/session.service.ts`): Управление пользовательскими сессиями.
*   `UserAccountService` (`src/auth/user-account.service.ts`): Управление учетными записями пользователей.

**Стратегии**:
*   `JwtStrategy` (`src/auth/strategies/jwt.strategy.ts`): Стратегия Passport.js для аутентификации с помощью JWT.

**Сущности (Entities)**:
*   `User` (`src/auth/entities/user.entity.ts`): Модель пользователя.
*   `Session` (`src/auth/entities/session.entity.ts`): Модель сессии пользователя.

**DTO**:
*   `AuthLoginDto` (`src/auth/dto/login.dto.ts`): DTO для входа пользователя.
*   `AuthRegisterDto` (`src/auth/dto/register.dto.ts`): DTO для регистрации пользователя.
*   `RefreshTokenDto` (`src/auth/dto/refresh-token.dto.ts`): DTO для обновления токена.
*   `UserResponseDto` (`src/auth/dto/user-response.dto.ts`): DTO для ответа с информацией о пользователе.

**Интерфейсы**:
*   `IJwtPayload` (`src/auth/interfaces/jwt-payload.interface.ts`): Интерфейс для JWT Payload.

#### CharacterModule

**Описание**: Управляет всей логикой, связанной с интеллектуальными персонажами: их созданием, управлением состоянием (эмоции, мотивации, потребности), поведенческими паттернами и взаимодействием с пользователями.

**Путь**: `src/character/`

**Контроллеры**:
*   `CharacterController` (`src/character/controllers/character.controller.ts`): Эндпоинты для управления персонажами (создание, получение, обновление, удаление).
*   `StoryController` (`src/character/controllers/story.controller.ts`): Обрабатывает запросы, связанные с историей персонажей.

**Сервисы**:
*   `CharacterService` (`src/character/character.service.ts`): Основной сервис для управления персонажами.
*   `NeedsService` (`src/character/services/core/needs.service.ts`): Сервис для управления потребностями персонажей.
*   `EmotionalStateService` (`src/character/services/core/emotional-state.service.ts`): Сервис для управления эмоциональным состоянием персонажей.
*   `MotivationService` (`src/character/services/core/motivation.service.ts`): Сервис для управления мотивациями персонажей.
*   `PersonalityService` (`src/character/services/core/personality.service.ts`): Сервис для управления чертами личности.
*   `BehaviorService` (`src/character/services/core/behavior.service.ts`): Сервис для управления поведенческими паттернами.
*   `DecisionService` (`src/character/services/core/decision.service.ts`): Сервис для принятия решений персонажем.
*   `MessageAnalysisService` (`src/character/services/analysis/message-analysis.service.ts`): Анализ сообщений пользователя для определения намерений, эмоций и контекста.
*   `ContextCompressionService` (`src/character/services/analysis/context-compression.service.ts`): Сервис для сжатия и управления контекстом диалога и долгосрочной памятью.
*   `CharacterAIService` (`src/character/services/core/character-ai.service.ts`): Объединяет AI-компоненты для генерации ответов и поведенческой логики.
*   `ActionService` (`src/character/services/action/action.service.ts`): Управление действиями персонажей.
*   `TechniqueExecutionService` (`src/character/services/technique/technique-execution.service.ts`): Выполнение техник влияния.
*   `UserManipulationProfileService` (`src/character/services/manipulation/user-manipulation-profile.service.ts`): Управление профилями манипуляции пользователей.

**Репозитории**:
*   `CharacterRepository` (`src/character/repositories/character.repository.ts`): Репозиторий для работы с сущностью `Character`.
*   `TechniqueExecutionRepository` (`src/character/repositories/technique-execution.repository.ts`): Репозиторий для `TechniqueExecution`.
*   `UserManipulationProfileRepository` (`src/character/repositories/user-manipulation-profile.repository.ts`): Репозиторий для `UserManipulationProfile`.

**Сущности (Entities)**:
*   `Action` (`src/character/entities/action.entity.ts`): Модель действия персонажа.
*   `CharacterMemory` (`src/character/entities/character-memory.entity.ts`): Долгосрочная память персонажа.
*   `CharacterMotivation` (`src/character/entities/character-motivation.entity.ts`): Мотивации персонажа.
*   `CharacterNeed` (`src/character/entities/character-need.entity.ts`): Потребности персонажа.
*   `CharacterPersonalityTrait` (`src/character/entities/character-personality-trait.entity.ts`): Черты личности персонажа.
*   `EmotionalState` (`src/character/entities/emotional-state.entity.ts`): Эмоциональное состояние персонажа.
*   `ManipulationTechnique` (`src/character/entities/manipulation-technique.entity.ts`): Техники манипуляции.
*   `TechniqueExecution` (`src/character/entities/technique-execution.entity.ts`): Записи о выполнении техник.
*   `UserManipulationProfile` (`src/character/entities/user-manipulation-profile.entity.ts`): Профиль манипуляции пользователя.
*   `Character` (`src/character/entities/character.entity.ts`): Основная модель персонажа.

**DTO**:
*   `CreateCharacterDto` (`src/character/dto/create-character.dto.ts`): DTO для создания персонажа.
*   `UpdateCharacterDto` (`src/character/dto/update-character.dto.ts`): DTO для обновления персонажа.
*   `GenerateCharacterNameDto` (`src/character/dto/generate-character-name.dto.ts`): DTO для генерации имени персонажа.

**Перечисления (Enums)**:
*   `ActionType` (`src/character/enums/action-type.enum.ts`): Типы действий персонажа.
*   `CharacterArchetype` (`src/character/enums/character-archetype.enum.ts`): Архетипы персонажей.
*   `CharacterNeedType` (`src/character/enums/character-need-type.enum.ts`): Типы потребностей персонажа.
*   `EmotionalStateEnum` (`src/character/enums/emotional-state.enum.ts`): Перечисление эмоциональных состояний.

**Интерфейсы**:
*   `IAnalysisService` (`src/character/interfaces/analysis.interfaces.ts`): Интерфейсы для сервисов анализа.
*   `IBehaviorService` (`src/character/interfaces/behavior.interfaces.ts`): Интерфейсы для сервисов поведения.
*   `ICharacterPersona` (`src/character/interfaces/character-persona.interface.ts`): Интерфейс для описания персоны персонажа.
*   `ICharacterService` (`src/character/interfaces/character-service.interface.ts`): Интерфейс для `CharacterService`.
*   `IDecisionService` (`src/character/interfaces/decision.interface.ts`): Интерфейс для сервиса принятия решений.
*   `IEvaluationService` (`src/character/interfaces/evaluation.interface.ts`): Интерфейс для сервиса оценки.
*   `IManipulationService` (`src/character/interfaces/manipulation.interface.ts`): Интерфейс для сервиса манипуляции.
*   `INeedsService` (`src/character/interfaces/needs.interface.ts`): Интерфейс для сервиса потребностей.
*   `ITechniqueService` (`src/character/interfaces/technique.interface.ts`): Интерфейс для сервиса техник.

#### ContextCompressionModule

**Описание**: Этот модуль отвечает за обработку, сжатие и архивацию долгосрочной памяти персонажей. Он использует `ContextCompressionService` для оптимизации хранения и доступа к обширным диалоговым данным, что критически важно для эффективной работы LLM.

**Путь**: `src/character/context-compression.module.ts`

**Сервисы**:
*   `ContextCompressionService` (`src/character/services/analysis/context-compression.service.ts`): Сервис, реализующий алгоритмы сжатия и управления долгосрочной памятью. Отвечает за извлечение ключевых смыслов, суммаризацию и архивацию диалогов.

**Сущности (Entities)**:
*   `CharacterMemory` (`src/character/entities/character-memory.entity.ts`): Сущность, представляющая фрагменты долгосрочной памяти персонажа, обрабатываемые и хранимые этим модулем.

#### StoryModule

**Описание**: Управляет повествованием и прогрессом истории для каждого персонажа. Отслеживает ключевые события, поддерживает консистентность сюжетной линии и влияет на генерацию диалогов в соответствии с развитием сюжета.

**Путь**: `src/story/`

**Сервисы**:
*   `StoryService` (`src/story/services/story.service.ts`): Основной сервис для управления историей персонажей, включая создание, обновление и отслеживание сюжетных линий.
*   `StorySeederService` (`src/story/services/story-seeder.service.ts`): Сервис для инициализации и заполнения базы данных базовыми данными истории.

**Сущности (Entities)**:
*   `CharacterStoryProgress` (`src/story/entities/character-story-progress.entity.ts`): Прогресс персонажа в сюжетной линии.
*   `StoryEvent` (`src/story/entities/story-event.entity.ts`): События, происходящие в истории персонажа.

**DTO**:
*   `CreateStoryEventDto` (`src/story/dto/create-story-event.dto.ts`): DTO для создания сюжетного события.

**Интерфейсы**:
*   `IStoryService` (`src/story/interfaces/story-service.interface.ts`): Интерфейс для `StoryService`.

#### LLMModule

**Описание**: Предоставляет интерфейс для взаимодействия с внешними Large Language Models (LLM), такими как OpenAI GPT, Google Gemini. Отвечает за формирование промптов, отправку запросов к LLM и обработку полученных ответов, а также за кэширование ответов LLM.

**Путь**: `src/llm/`

**Сервисы**:
*   `LLMService` (`src/llm/services/llm.service.ts`): Основной сервис для взаимодействия с LLM, включая формирование запросов и обработку ответов.
*   `LLMProviderManagerService` (`src/llm/services/llm-provider-manager.service.ts`): Управляет выбором и инициализацией различных LLM провайдеров.

**Провайдеры**:
*   `LlamaProviderService` (`src/llm/providers/llama-provider.service.ts`): Провайдер для Llama моделей.
*   `OpenAICoreService` (`src/llm/providers/openai-core.service.ts`): Базовый сервис для работы с OpenAI API.
*   `OpenAIProviderService` (`src/llm/providers/openai.provider.service.ts`): Провайдер для OpenAI моделей.

**Перечисления (Enums)**:
*   `LlmProvider` (`src/llm/enums/llm-provider.enum.ts`): Перечисление доступных провайдеров LLM.
*   `LlmModel` (`src/llm/enums/llm-model.enum.ts`): Перечисление доступных моделей LLM.

**Интерфейсы**:
*   `ILlmProvider` (`src/llm/interfaces/llm-provider.interface.ts`): Интерфейс для LLM провайдеров.
*   `ILlmResponse` (`src/llm/interfaces/llm-response.interface.ts`): Интерфейс для ответов LLM.
*   `ILLMService` (`src/llm/interfaces/llm-service.interface.ts`): Интерфейс для `LLMService`.

#### TelegramModule

**Описание**: Обеспечивает интеграцию с Telegram Bot API. Отвечает за прием входящих сообщений и команд от пользователей, а также за отправку ответов персонажей обратно в Telegram.

**Путь**: `src/telegram/`

**Контроллеры**: Контроллеры не представлены в `src/telegram/`.

**Сервисы**:
*   `TelegramService` (`src/telegram/telegram.service.ts`): Основной сервис для взаимодействия с Telegram Bot API, отправки и получения сообщений.
*   `TelegramBotApiService` (`src/telegram/services/telegram-bot-api.service.ts`): Низкоуровневый сервис для прямого взаимодействия с Telegram API.
*   `UpdateHandlerService` (`src/telegram/services/update-handler.service.ts`): Обрабатывает различные типы обновлений от Telegram.
*   `CallbackQueryService` (`src/telegram/services/callback-query.service.ts`): Обрабатывает колбэк-запросы от инлайн-кнопок.
*   `CommandService` (`src/telegram/services/command.service.ts`): Обрабатывает команды Telegram.
*   `InlineQueryService` (`src/telegram/services/inline-query.service.ts`): Обрабатывает инлайн-запросы.
*   `MessageProcessorService` (`src/telegram/services/message-processor.service.ts`): Обрабатывает входящие сообщения.
*   `StateService` (`src/telegram/services/state.service.ts`): Управляет состоянием пользователя в Telegram.
*   `MarkupService` (`src/telegram/services/markup.service.ts`): Создает клавиатуры и инлайн-кнопки.

**Декораторы**:
*   `AccessCheck` (`src/telegram/decorators/access-check.decorator.ts`): Декоратор для проверки прав доступа.
*   `ErrorHandler` (`src/telegram/decorators/error-handling.decorator.ts`): Декоратор для обработки ошибок.
*   `LogActivity` (`src/telegram/decorators/log-activity.decorator.ts`): Декоратор для логирования активности.
*   `Message` (`src/telegram/decorators/message.decorator.ts`): Декоратор для обработки сообщений.
*   `On` (`src/telegram/decorators/on.decorator.ts`): Декоратор для обработки различных типов обновлений.
*   `UseState` (`src/telegram/decorators/use-state.decorator.ts`): Декоратор для работы с состоянием.

**Сущности (Entities)**:
*   `CharacterSettings` (`src/telegram/entities/character-settings.entity.ts`): Настройки персонажа для Telegram-пользователя.
*   `TelegramUser` (`src/telegram/entities/telegram-user.entity.ts`): Модель пользователя Telegram.
*   `UserSession` (`src/telegram/entities/user-session.entity.ts`): Сессия пользователя Telegram.

**Обработчики (Handlers)**:
*   `BaseHandler` (`src/telegram/handlers/base.handler.ts`): Базовый класс для обработчиков Telegram-обновлений.
*   `CallbackQueryHandler` (`src/telegram/handlers/callback-query.handler.ts`): Обработчик колбэк-запросов.
*   `CommandHandler` (`src/telegram/handlers/command.handler.ts`): Обработчик команд.
*   `MessageHandler` (`src/telegram/handlers/message.handler.ts`): Обработчик сообщений.

**Интерфейсы**:
*   `IContext` (`src/telegram/interfaces/context.interface.ts`): Интерфейс для контекста Telegram.
*   `IState` (`src/telegram/interfaces/state.interface.ts`): Интерфейс для состояния пользователя.
*   `ITelegramUpdate` (`src/telegram/interfaces/telegram-update.interface.ts`): Интерфейс для обновлений Telegram.

**Константы**:
*   `STATES` (`src/telegram/constants/states.ts`): Константы для состояний Telegram-бота.
*   `TOKENS` (`src/telegram/constants/tokens.ts`): Константы для токенов Telegram.

#### DialogModule

**Описание**: Управляет логикой диалогов, включая анализ пользовательских сообщений, поддержание контекста диалога и генерацию ответов. Отвечает за интеграцию с LLM и поведенческой логикой персонажей в рамках диалога.

**Путь**: `src/dialog/`

**Контроллеры**:
*   `DialogController` (`src/dialog/controllers/dialog.controller.ts`): Обрабатывает HTTP-запросы, связанные с диалогами (например, отправка сообщения персонажу).

**Сервисы**:
*   `DialogService` (`src/dialog/services/dialog.service.ts`): Основной сервис для управления диалогами.

**Сущности (Entities)**:
*   `Dialog` (`src/dialog/entities/dialog.entity.ts`): Модель диалога.
*   `Message` (`src/dialog/entities/message.entity.ts`): Модель сообщения в диалоге.

**DTO**:
*   `CreateMessageDto` (`src/dialog/dto/create-message.dto.ts`): DTO для создания сообщения.
*   `CreateProactiveMessageDto` (`src/dialog/dto/create-proactive-message.dto.ts`): DTO для создания проактивного сообщения.

**Интерфейсы**:
*   `ICreateDialog` (`src/dialog/interfaces/create-dialog.interface.ts`): Интерфейс для создания диалога.

#### NeedsService (Подробное описание)

**Описание**: Является частью `CharacterModule` и отвечает за моделирование и управление динамическими потребностями персонажей. Отслеживает удовлетворенность потребностей, их изменение со временем и влияние на поведение персонажа.

**Путь**: `src/character/services/core/needs.service.ts`

**Ключевые функции**:
*   **Оценка потребностей**: Пересчитывает текущие уровни потребностей (голод, усталость, социализация и т.д.) на основе внутренних состояний и внешних событий.
*   **Влияние на поведение**: Определяет, как неудовлетворенные потребности влияют на мотивацию персонажа, его эмоциональное состояние и выбор действий.
*   **Триггеры**: Генерирует события или триггеры, когда определенные потребности достигают критического уровня (например, фрустрация).

#### CommonModule

**Описание**: Содержит общие утилиты, абстракции, конфигурации, декораторы, перехватчики, интерфейсы, промежуточное ПО и вспомогательные функции, используемые по всему приложению. Этот модуль помечен как `@Global()`, что делает его сервисы доступными в любом другом модуле без явного импорта.

**Путь**: `src/common/`

**Контроллеры**: `ApiСontroller` (`src/common/controllers/api.controller.ts`)

**Абстракции**:
*   `EntityManagerAbstract` (`src/common/abstractions/entity-manager.abstract.ts`): Абстрактный класс для управления сущностями, предоставляющий базовые операции CRUD.
*   `PatternUtils` (`src/common/abstractions/pattern-utils.ts`): Утилиты для работы с различными паттернами, например, для преобразования строк или объектов.

**Базовые сервисы**:
*   `BaseService` (`src/common/base/base.service.ts`): Базовый класс для сервисов, предоставляющий общую логику и утилиты.

**Конфигурации**:
*   `CacheConfig` (`src/common/config/cache.config.ts`): Конфигурация для настроек кэширования.
*   `Configuration` (`src/common/config/configuration.ts`): Основная конфигурация приложения.
*   `CorsConfig` (`src/common/config/cors.config.ts`): Конфигурация для CORS.
*   `SwaggerConfig` (`src/common/config/swagger.config.ts`): Конфигурация для Swagger.

**Декораторы**:
*   `RetryDecorator` (`src/common/decorators/retry.decorator.ts`): Декоратор для повторного выполнения функций при сбоях.
*   `SanitizeDecorator` (`src/common/decorators/sanitize.decorator.ts`): Декоратор для очистки данных.
*   `ValidationRuleDecorator` (`src/common/decorators/validation-rule.decorator.ts`): Декоратор для применения правил валидации.

**Guard'ы**:
*   `ApiKeyGuard` (`src/common/guards/api-key.guard.ts`): Guard для проверки API-ключей.
*   `GuardsModule` (`src/common/guards/guards.module.ts`): Модуль для guards.
*   `PublicDecorator` (`src/common/guards/public.decorator.ts`): Декоратор для пометки публичных маршрутов, не требующих аутентификации.
*   `ThrottlerGuard` (`src/common/guards/throttler.guard.ts`): Guard для ограничения частоты запросов.

**HTTP-клиент**:
*   `ErrorHandledHttpClient` (`src/common/http/error-handled-http.client.ts`): HTTP-клиент с обработкой ошибок.
*   `HttpClientModule` (`src/common/http/http-client.module.ts`): Модуль для HTTP-клиента.

**Интерцепторы**:
*   `SanitizeRequestInterceptor` (`src/common/interceptors/sanitize-request.interceptor.ts`): Интерцептор для очистки входящих запросов.

**Интерфейсы**:
*   `IApiKey` (`src/common/interfaces/api-key.interface.ts`)
*   `IDomain` (`src/common/interfaces/domain.interface.ts`)
*   `IErrorHandler` (`src/common/interfaces/error-handler.interface.ts`)
*   `IHttpRequest` (`src/common/interfaces/http-request.interface.ts`)
*   `IHttpResponse` (`src/common/interfaces/http-response.interface.ts`)
*   `IProcessManager` (`src/common/interfaces/process-manager.interface.ts`)
*   `IQueueService` (`src/common/interfaces/queue-service.interface.ts`)
*   `IRequestConfig` (`src/common/interfaces/request-config.interface.ts`)
*   `ITestableService` (`src/common/interfaces/testable-service.interface.ts`)
*   `IValidationRule` (`src/common/interfaces/validation-rule.interface.ts`)
*   `IBaseService` (`src/common/interfaces/base-service.interface.ts`)
*   `ISanitizeRequest` (`src/common/interfaces/sanitize-request.interface.ts`)

**Промежуточное ПО (Middleware)**:
*   `ApiKeyMiddleware` (`src/common/middleware/api-key.middleware.ts`): Промежуточное ПО для проверки API-ключей.
*   `RequestTrackerMiddleware` (`src/common/middleware/request-tracker.middleware.ts`): Промежуточное ПО для отслеживания запросов.

**Типы**:
*   `CommonTypes` (`src/common/types/common-types.ts`): Общие типы данных.

**Утилиты**:
*   `CorsValidator` (`src/common/utils/cors-validator.util.ts`): Утилита для валидации CORS.
*   `DatabaseModule` (`src/common/utils/database.module.ts`): Модуль для работы с базой данных.
*   `DbConnectionChecker` (`src/common/utils/db/db-connection-checker.ts`): Утилита для проверки соединения с БД.
*   `DbSource` (`src/common/utils/db/db-source.ts`): Утилита для получения источника БД.
*   `ErrorHandlingService` (`src/common/utils/error-handling/error-handling.service.ts`): Сервис для централизованной обработки ошибок.
*   `HttpExceptionFilter` (`src/common/utils/error-handling/http-exception.filter.ts`): Фильтр HTTP-исключений.
*   `ValidationExceptionFilter` (`src/common/utils/error-handling/validation-exception.filter.ts`): Фильтр исключений валидации.
*   `ErrorUtils` (`src/common/utils/error.utils.ts`): Утилиты для работы с ошибками.
*   `HeaderSanitizer` (`src/common/utils/header-sanitizer.util.ts`): Утилита для очистки заголовков.
*   `PortValidator` (`src/common/utils/port-validator.util.ts`): Утилита для валидации портов.
*   `QueryUtils` (`src/common/utils/query/query.utils.ts`): Утилиты для оптимизированных запросов к базе данных.
*   `ResponseUtils` (`src/common/utils/response.utils.ts`): Утилиты для формирования ответов.
*   `ValidationUtils` (`src/common/utils/validation.utils.ts`): Утилиты для валидации.

#### CacheModule

**Описание**: Предоставляет централизованный кэш-слой для хранения часто используемых данных с поддержкой TTL, сериализации и инвалидации. Модуль помечен как `@Global()`, поэтому `CacheService` доступен во всём приложении без явного импорта.

**Путь**: `src/cache/`

**Сервисы**:
*   `CacheService` (`src/cache/cache.service.ts`): Реализация операций `get`, `set`, `del`, `reset`, а также автоматическое управление сроком жизни записей.

**Интерфейсы**:
*   `ICacheService` (`src/cache/cache.interface.ts`): Контракт сервиса кэширования.

#### InfrastructureModule

**Описание**: Содержит инфраструктурные сервисы, необходимые остальным модулям: управление API-ключами, шифрование/дешифрование данных и др. Модуль объявлен `@Global()` для упрощённого доступа.

**Путь**: `src/infrastructure/`

**Сервисы**:
*   `ApiKeyService` (`src/infrastructure/api-key.service.ts`): Управление жизненным циклом API-ключей.
*   `EncryptionService` (`src/infrastructure/encryption.service.ts`): Предоставляет методы шифрования и дешифрования для конфиденциальных данных.

#### LoggingModule

**Описание**: Централизует логирование и обработку исключений. Поддерживает вывод в консоль, файл и внешние системы (Rollbar).

**Путь**: `src/logging/`

**Сервисы**:
*   `LogService` (`src/logging/log.service.ts`): Базовый сервис логирования уровней INFO/ERROR/DEBUG.
*   `RollbarService` (`src/logging/rollbar.service.ts`): Интеграция с Rollbar для отправки ошибок.

**Фильтры и Middleware**:
*   `GlobalExceptionFilter` (`src/logging/global-exception.filter.ts`): Перехватывает необработанные исключения и направляет их в лог.
*   `HttpLoggerMiddleware` (`src/logging/http-logger.middleware.ts`): Логирование входящих HTTP-запросов и ответов.

#### PromptTemplateModule

**Описание**: Управляет шаблонами промптов (Handlebars) для генерации запросов к LLM. Позволяет версионировать шаблоны и быстро переключать их без изменения кода.

**Путь**: `src/prompt-template/`

**Сервисы**:
*   `PromptTemplateService` (`src/prompt-template/prompt-template.service.ts`): CRUD по шаблонам, рендеринг с контекстом, кеширование скомпилированных шаблонов.

#### ValidationModule

**Описание**: Предоставляет инфраструктуру валидации входящих данных, включая глобальный `ValidationPipe`, обработку ошибок и набор стандартных правил.

**Путь**: `src/validation/`

**Сервисы**:
*   `ValidationService` (`src/validation/services/validation.service.ts`): Выполнение кастомных правил и схем валидации.
*   `ValidationErrorHandler` (`src/validation/services/validation-error-handler.service.ts`): Централизованная обработка ошибок валидации.

**Pipe**:
*   `GlobalValidationPipe` (`src/validation/pipes/global-validation.pipe.ts`): Подключается в `AppModule` как глобальный `pipe` для всех маршрутов.

**Правила (Rules)**:
*   `standardRules` (`src/validation/rules/standard-rules.ts`): Базовый набор правил (строка не пуста, email валиден, диапазоны чисел и т.п.).

#### MonitoringModule

**Описание**: Отвечает за сбор метрик, мониторинг состояния системы, управление оповещениями и оптимизацию производительности. Модуль интегрируется с Prometheus и Grafana для визуализации данных и настройки алертов. Он включает сервисы для отслеживания системных, API и пользовательских метрик, а также для автоматической оптимизации базы данных и масштабирования.

**Путь**: `src/monitoring/`

**Контроллеры**:
*   `MonitoringController` (`src/monitoring/controllers/monitoring.controller.ts`): Предоставляет API-эндпоинты для получения системных и API метрик, управления оповещениями и получения рекомендаций по оптимизации.
*   `DatabaseOptimizerController` (`src/monitoring/controllers/optimizer.controller.ts`): Отвечает за эндпоинты, связанные с оптимизацией базы данных, включая получение метрик и рекомендаций, а также запуск процессов оптимизации.

**Сервисы**:
*   `MonitoringService` (`src/monitoring/monitoring.service.ts`): Основной сервис мониторинга, отвечающий за сбор и хранение метрик различных типов (системные, API, пользовательские).
*   `AlertService` (`src/monitoring/services/alert.service.ts`): Управляет созданием, получением, подтверждением, разрешением и очисткой оповещений. Интегрирован с системой уведомлений.
*   `OptimizationService` (`src/monitoring/services/optimization.service.ts`): Предоставляет функциональность для оптимизации базы данных и автоматического масштабирования ресурсов, а также генерации рекомендаций.

**Промежуточное ПО (Middleware)**:
*   `MetricsMiddleware` (`src/monitoring/middleware/metrics.middleware.ts`): Промежуточное ПО для сбора метрик HTTP-запросов (времени ответа, статусов и т.д.).

**Guard'ы**:
*   `PrometheusAuthGuard` (`src/monitoring/guards/prometheus-auth.guard.ts`): Guard для защиты эндпоинтов Prometheus метрик с помощью API-ключа.

**Перечисления (Enums)**:
*   `HealthStatus` (`src/monitoring/enums/health-status.enum.ts`): Статусы здоровья системы (HEALTHY, WARNING, CRITICAL, UNKNOWN).
*   `UserMetricType` (`src/monitoring/entities/user-metric.entity.ts`): Типы пользовательских метрик (SESSION, MESSAGE, COMMAND, CHARACTER_CREATION, CHARACTER_INTERACTION, API_USAGE).
*   `RecommendationType` (`src/monitoring/entities/optimizer-recommendation.entity.ts`): Типы рекомендаций оптимизатора (CREATE_INDEX, DROP_INDEX, VACUUM и т.д.).
*   `RecommendationStatus` (`src/monitoring/entities/optimizer-recommendation.entity.ts`): Статусы рекомендаций (PENDING, APPLIED, IGNORED, FAILED, SCHEDULED).
*   `RecommendationPriority` (`src/monitoring/entities/optimizer-recommendation.entity.ts`): Приоритеты рекомендаций (LOW, MEDIUM, HIGH, CRITICAL).
*   `SystemMetricType` (`src/monitoring/entities/system-metric.entity.ts`): Типы системных метрик (CPU, MEMORY, DISK, LOAD, UPTIME, NETWORK).
*   `AlertType` (`src/monitoring/entities/alert.entity.ts`): Типы оповещений (SYSTEM, API, SECURITY, PERFORMANCE, DATABASE, APPLICATION, USER).
*   `AlertSeverity` (`src/monitoring/entities/alert.entity.ts`): Уровни важности оповещений (INFO, WARNING, ERROR, CRITICAL).
*   `AlertStatus` (`src/monitoring/entities/alert.entity.ts`): Статусы оповещений (NEW, ACKNOWLEDGED, RESOLVED, IGNORED).
*   `ApiMetricType` (`src/monitoring/entities/api-metric.entity.ts`): Типы метрик API (OPENAI, TELEGRAM, INTERNAL, EXTERNAL).
*   `AggregationPeriod` (`src/monitoring/entities/metric-aggregation.entity.ts`): Периоды агрегации метрик (MINUTE, HOUR, DAY, WEEK, MONTH).

**Сущности (Entities)**:
*   `UserMetric` (`src/monitoring/entities/user-metric.entity.ts`): Метрики, связанные с активностью пользователей.
*   `OptimizerRecommendation` (`src/monitoring/entities/optimizer-recommendation.entity.ts`): Сущность для хранения рекомендаций по оптимизации базы данных.
*   `MetricBase` (`src/monitoring/entities/metric-base.entity.ts`): Базовый класс для всех метрик.
*   `SystemMetric` (`src/monitoring/entities/system-metric.entity.ts`): Метрики системных ресурсов (CPU, RAM, диск).
*   `Alert` (`src/monitoring/entities/alert.entity.ts`): Сущность для хранения информации об оповещениях.
*   `ApiMetric` (`src/monitoring/entities/api-metric.entity.ts`): Метрики использования API.
*   `ScalingRule` (`src/monitoring/entities/scaling-rule.entity.ts`): Правила автоматического масштабирования.
*   `ScalingOperation` (`src/monitoring/entities/scaling-operation.entity.ts`): Записи об выполненных операциях масштабирования.
*   `MetricAggregation` (`src/monitoring/entities/metric-aggregation.entity.ts`): Сущность для хранения агрегированных метрик за определенные периоды.

**Интерфейсы**: Директория `src/monitoring/interfaces/` пуста.

**Grafana Dashboards и Alert Rules**:
*   `alert-rules.yaml`: Правила оповещений Prometheus.
*   `database-dashboard.json`: Дашборд Grafana для мониторинга базы данных.
*   `database-optimizer-dashboard.json`: Дашборд Grafana для оптимизатора базы данных.
*   `health-system-dashboard.json`: Дашборд Grafana для общего здоровья системы.
*   `redis-cache-dashboard.json`: Дашборд Grafana для мониторинга кэша Redis.
*   `scaling-dashboard.json`: Дашборд Grafana для мониторинга масштабирования.
*   `system-performance-dashboard.json`: Дашборд Grafana для системной производительности.
*   `user-activity-dashboard.json`: Дашборд Grafana для активности пользователей.

---


## 3. Проектирование базы данных

### 3.1. Сущности и их атрибуты

Проектирование базы данных для системы интеллектуальных персонажей требует тщательного анализа предметной области и создания модели данных, которая эффективно поддерживает сложную поведенческую логику, управление памятью и историчность взаимодействий. База данных должна обеспечивать высокую производительность при частых операциях чтения и записи, поддерживать сложные запросы для анализа поведения персонажей и предоставлять гибкость для будущих расширений функциональности.

#### 3.1.1. Сущность Character (Персонаж)

Сущность Character представляет центральную концепцию системы - интеллектуального персонажа со всеми его характеристиками и параметрами. Эта сущность содержит как статические атрибуты, определяющие базовую личность персонажа, так и динамические параметры, которые изменяются в процессе взаимодействия.

Атрибуты сущности Character включают уникальный идентификатор (character_id) типа UUID, обеспечивающий глобальную уникальность персонажа в системе. Имя персонажа (name) хранится как строка переменной длины до 100 символов и представляет публичное имя, под которым персонаж взаимодействует с пользователями. Описание персонажа (description) содержит детальную характеристику личности, предыстории, особенностей поведения и может достигать 2000 символов.

Базовые параметры личности включают экстраверсию (extraversion), доброжелательность (agreeableness), добросовестность (conscientiousness), нейротизм (neuroticism) и открытость опыту (openness), представленные как числовые значения с плавающей точкой в диапазоне от 0.0 до 1.0. Эти параметры основаны на модели "Большой пятерки" личностных черт и служат основой для формирования поведенческих паттернов персонажа.

Дата создания (created_at) и последнего обновления (updated_at) фиксируются автоматически для отслеживания жизненного цикла персонажа. Статус активности (is_active) определяет, доступен ли персонаж для взаимодействия с пользователями. Версия персонажа (version) используется для поддержки версионирования и отслеживания изменений в характеристиках персонажа.

#### 3.1.2. Сущность Need (Потребность)

Сущность Need моделирует систему потребностей персонажа, основанную на психологических теориях мотивации. Каждая потребность представлена как динамическая переменная с текущим уровнем удовлетворения, базовым уровнем, скоростью изменения и приоритетом.

**Базовые потребности** включают потребность в безопасности, которая влияет на готовность персонажа делиться личной информацией, доверять пользователю, исследовать новые темы. Низкий уровень безопасности делает персонажа более осторожным, склонным к избеганию конфликтов, предпочитающим знакомые темы разговора.

**Социальные потребности** охватывают потребность в принадлежности, признании, внимании. Неудовлетворенная потребность во внимании может проявляться через более активное участие в диалоге, задавание большего количества вопросов, попытки привлечь интерес пользователя к своей личности или опыту.

**Потребности роста** включают потребность в автономии, компетентности, самореализации. Персонаж с высокой потребностью в автономии будет проявлять больше инициативы в диалоге, предлагать собственные идеи, выражать независимые мнения. Потребность в компетентности влияет на желание демонстрировать знания, помогать пользователю, решать проблемы.

Алгоритм обновления потребностей учитывает взаимодействие с пользователем, течение времени, достижение целей, внешние события. Удовлетворение одной потребности может влиять на уровень других потребностей, создавая сложную динамику внутреннего состояния персонажа.

#### 3.1.3. Сущность Motivation (Мотивация)

Сущность Motivation представляет текущие мотивационные факторы, которые движут поведением персонажа в конкретный момент времени. Мотивации формируются на основе анализа потребностей, эмоционального состояния, контекста взаимодействия и внешних стимулов.

Атрибуты включают идентификатор мотивации (motivation_id), ссылку на персонажа (character_id), тип мотивации (motivation_type) из категорий таких как достижение, избегание, исследование, социализация, доминирование, подчинение. Интенсивность мотивации (intensity) выражается числом от 0.0 до 1.0 и определяет силу влияния данной мотивации на поведение.

Источник мотивации (source) указывает, что привело к возникновению данной мотивации - неудовлетворенная потребность, внешний стимул, эмоциональная реакция. Время активации (activated_at) и предполагаемое время деактивации (expires_at) определяют жизненный цикл мотивации. Связанные действия (associated_actions) содержат JSON-структуру с описанием конкретных поведенческих паттернов, которые может активировать данная мотивация.

#### 3.1.4. Сущность Action (Действие)

Сущность Action фиксирует конкретные действия, предпринятые персонажем в процессе взаимодействия. Это могут быть как внешние действия (отправка сообщения, задавание вопроса, выражение эмоции), так и внутренние процессы (обновление памяти, изменение эмоционального состояния).

Ключевые атрибуты включают идентификатор действия (action_id), ссылку на персонажа (character_id), тип действия (action_type) из категорий таких как message_sent, question_asked, emotion_expressed, memory_updated, need_addressed. Описание действия (description) содержит детальную информацию о том, что именно было сделано.

Контекст действия (context) хранится в JSON-формате и может включать информацию о состоянии персонажа на момент действия, внешних факторах, которые повлияли на решение, связанных мотивациях и потребностях. Результат действия (result) описывает наблюдаемые последствия - реакцию пользователя, изменения в состоянии персонажа, достижение целей.

Временные метки создания (created_at) и завершения (completed_at) позволяют анализировать продолжительность действий и их последовательность. Успешность действия (success_rating) оценивается по шкале от 0.0 до 1.0 на основе достижения поставленных целей.

#### 3.1.5. Сущность StoryMilestone (Сюжетный милестоун)

Сущность StoryMilestone отслеживает ключевые события и достижения в развитии отношений между персонажем и пользователем. Милестоуны служат для поддержания нарративной структуры взаимодействия и обеспечения последовательности в развитии истории.

Атрибуты включают идентификатор милестоуна (milestone_id), ссылку на персонажа (character_id), идентификатор пользователя (user_id), тип милестоуна (milestone_type) из категорий таких как first_contact, trust_established, conflict_resolved, deep_conversation, emotional_breakthrough. Название милестоуна (title) и описание (description) предоставляют человекочитаемую информацию о событии.

Условия достижения (achievement_conditions) описывают в JSON-формате критерии, которые должны быть выполнены для активации милестоуна. Влияние на отношения (relationship_impact) количественно оценивает, как достижение данного милестоуна влияет на различные аспекты отношений между персонажем и пользователем.

Дата достижения (achieved_at) фиксирует момент активации милестоуна. Связанные действия (related_actions) содержат ссылки на конкретные действия персонажа, которые привели к достижению милестоуна.

#### 3.1.6. Сущность EmotionalState (Эмоциональное состояние)

Сущность EmotionalState представляет текущее эмоциональное состояние персонажа в многомерном пространстве эмоций. Модель поддерживает как базовые эмоции, так и сложные эмоциональные состояния, обеспечивая реалистичную динамику эмоциональных переживаний.

Основные атрибуты включают идентификатор состояния (state_id), ссылку на персонажа (character_id), временную метку (timestamp) для отслеживания изменений во времени. Базовые эмоции представлены отдельными полями: радость (joy), грусть (sadness), гнев (anger), страх (fear), удивление (surprise), отвращение (disgust), каждая со значением интенсивности от 0.0 до 1.0.

Сложные эмоциональные состояния включают фрустрацию (frustration), энтузиазм (enthusiasm), меланхолию (melancholy), тревожность (anxiety), удовлетворенность (contentment). Общий эмоциональный тон (overall_mood) характеризует доминирующее эмоциональное состояние персонажа.

Стабильность эмоционального состояния (stability) показывает, насколько устойчиво текущее состояние к внешним воздействиям. Триггеры изменения (change_triggers) в JSON-формате описывают события или факторы, которые привели к текущему эмоциональному состоянию.

#### 3.1.7. Сущность DialogEntry (Запись диалога)

Сущность DialogEntry хранит отдельные сообщения и взаимодействия в рамках диалога между персонажем и пользователем. Эта сущность обеспечивает детальную историю всех коммуникаций и служит основой для анализа паттернов взаимодействия.

Ключевые атрибуты включают идентификатор записи (entry_id), ссылку на персонажа (character_id), идентификатор пользователя (user_id), идентификатор сессии диалога (session_id) для группировки связанных сообщений. Тип записи (entry_type) различает сообщения пользователя (user_message), ответы персонажа (character_response), системные события (system_event).

Содержание сообщения (content) хранит текст сообщения, а метаданные (metadata) в JSON-формате содержат дополнительную информацию такую как эмоциональный тон, использованные техники влияния, ссылки на активированные мотивации. Временная метка (timestamp) фиксирует точное время создания записи.

Контекст на момент сообщения (context_snapshot) сохраняет состояние персонажа в момент генерации ответа, что позволяет анализировать, как изменения в состоянии влияют на поведение. Оценка качества (quality_rating) может быть установлена автоматически или вручную для анализа эффективности диалогов.

#### 3.1.8. Сущность CompressedContext (Сжатый контекст)

Сущность CompressedContext хранит результаты сжатия долгосрочной памяти персонажа. Эта сущность критически важна для оптимизации производительности системы и управления большими объемами исторических данных.

Атрибуты включают идентификатор сжатого контекста (context_id), ссылку на персонажа (character_id), тип контекста (context_type) из категорий таких как dialog_summary, relationship_history, learned_facts, behavioral_patterns. Временной диапазон (time_range_start, time_range_end) определяет период, который покрывает данный сжатый контекст.

Сжатое содержание (compressed_content) хранит результат применения алгоритмов сжатия к исходным данным. Ключевые концепции (key_concepts) в JSON-формате содержат извлеченные важные темы, факты, паттерны поведения. Уровень важности (importance_level) от 0.0 до 1.0 определяет приоритет данного контекста при формировании промптов.

Алгоритм сжатия (compression_algorithm) указывает, какой метод был использован для создания сжатого представления. Исходные данные (source_data_refs) содержат ссылки на оригинальные записи, которые были сжаты. Дата создания (created_at) и срок действия (expires_at) управляют жизненным циклом сжатых данных.

#### 3.1.9. Сущность ManipulationTechnique (Техника влияния)

Сущность ManipulationTechnique определяет доступные техники психологического влияния, которые персонаж может применять в диалоге. Эта сущность требует особого внимания к этическим аспектам и должна включать механизмы контроля и ограничения.

Основные атрибуты включают идентификатор техники (technique_id), название (name) и описание (description) техники влияния. Категория техники (category) классифицирует методы по типам воздействия: убеждение, эмоциональное воздействие, социальное давление, когнитивные искажения.

Условия активации (activation_conditions) в JSON-формате описывают обстоятельства, при которых данная техника может быть применена - определенные эмоциональные состояния персонажа, типы мотиваций, характеристики пользователя. Этические ограничения (ethical_constraints) определяют границы допустимого использования техники.

Эффективность техники (effectiveness_rating) оценивается на основе исторических данных о результатах применения. Частота использования (usage_frequency) отслеживает, как часто данная техника применяется различными персонажами. Уровень риска (risk_level) от 0.0 до 1.0 оценивает потенциальный вред от применения техники.

Примеры применения (usage_examples) содержат конкретные сценарии использования техники в диалогах. Связанные мотивации (associated_motivations) указывают, какие мотивационные состояния персонажа могут привести к активации данной техники.

### 3.2. ER-диаграмма и связи

Проектирование связей между сущностями в базе данных системы интеллектуальных персонажей требует тщательного анализа бизнес-логики и обеспечения целостности данных при высокой производительности операций чтения и записи.

#### 3.2.1. Основные связи между сущностями

Центральной сущностью в модели данных является Character, которая связана с большинством других сущностей через отношения "один ко многим". Персонаж может иметь множество потребностей (Character → Need), мотиваций (Character → Motivation), действий (Character → Action), эмоциональных состояний (Character → EmotionalState), записей диалогов (Character → DialogEntry), сжатых контекстов (Character → CompressedContext) и сюжетных милестоунов (Character → StoryMilestone).

Связь между Character и Need реализована через внешний ключ character_id в таблице Need. Эта связь имеет каскадное удаление, что означает автоматическое удаление всех потребностей при удалении персонажа. Индекс на поле character_id обеспечивает быстрый поиск всех потребностей конкретного персонажа.

Аналогично организованы связи Character с Motivation, Action и EmotionalState. Каждая из этих сущностей содержит внешний ключ character_id и поддерживает каскадное удаление. Дополнительные индексы на временные поля (created_at, timestamp) обеспечивают эффективные запросы для получения данных за определенные периоды времени.

#### 3.2.2. Связи с пользователями

Хотя сущность User не входит в основную модель данных системы персонажей, связи с пользователями реализованы через поле user_id в соответствующих таблицах. DialogEntry содержит как character_id, так и user_id, что позволяет отслеживать диалоги между конкретными персонажами и пользователями.

StoryMilestone также связан с пользователями через user_id, поскольку сюжетные милестоуны специфичны для отношений между конкретным персонажем и пользователем. Составной индекс на (character_id, user_id) обеспечивает быстрый поиск милестоунов для конкретной пары персонаж-пользователь.

#### 3.2.3. Связи между поведенческими сущностями

Между сущностями Need, Motivation и Action существуют логические связи, которые не всегда выражены через прямые внешние ключи, но реализованы через JSON-поля и бизнес-логику приложения.

Motivation может ссылаться на конкретные Need через поле source, которое содержит JSON-структуру с идентификаторами связанных потребностей. Это позволяет отслеживать, какие неудовлетворенные потребности привели к возникновению определенных мотиваций.

Action связан с Motivation через поле context, которое может содержать ссылки на мотивации, повлиявшие на принятие решения о выполнении действия. Обратная связь реализована через поле associated_actions в Motivation, которое содержит список действий, которые могут быть предприняты для удовлетворения данной мотивации.

#### 3.2.4. Связи памяти и контекста

CompressedContext связан с DialogEntry через поле source_data_refs, которое содержит массив идентификаторов исходных записей диалога, использованных для создания сжатого представления. Эта связь позволяет при необходимости восстановить детальную информацию из сжатых данных.

DialogEntry может ссылаться на CompressedContext через поле metadata, когда ответ персонажа был сгенерирован с использованием сжатого контекста. Это обеспечивает трассируемость источников информации, использованной для генерации ответов.

#### 3.2.5. Связи техник влияния

ManipulationTechnique связана с другими сущностями через JSON-поля и логику приложения. DialogEntry может содержать в metadata информацию о примененных техниках влияния. Action может ссылаться на использованные техники через поле context.

EmotionalState и Motivation связаны с ManipulationTechnique через поля activation_conditions и associated_motivations, которые определяют, при каких условиях конкретные техники могут быть активированы.

#### 3.2.6. Индексирование и оптимизация

Для обеспечения высокой производительности системы создана комплексная стратегия индексирования:

Первичные индексы на всех идентификаторах сущностей (character_id, need_id, motivation_id и т.д.) обеспечивают быстрый поиск по уникальным ключам. Вторичные индексы на внешних ключах (character_id в зависимых таблицах) ускоряют операции соединения таблиц.

Временные индексы на полях created_at, updated_at, timestamp критически важны для запросов, фильтрующих данные по времени. Составные индексы на комбинациях (character_id, timestamp) оптимизируют частые запросы для получения хронологически упорядоченных данных конкретного персонажа.

Функциональные индексы на JSON-полях позволяют эффективно искать по содержимому структурированных данных в полях metadata, context, activation_conditions. Полнотекстовые индексы на полях description, content обеспечивают быстрый поиск по содержанию текстовых данных.

### 3.3. Поддержка историчности и версионирования

Система интеллектуальных персонажей требует сохранения полной истории изменений для анализа развития персонажей, отладки поведенческих алгоритмов и обеспечения возможности отката к предыдущим состояниям.

#### 3.3.1. Версионирование персонажей

Каждое изменение в характеристиках персонажа создает новую версию записи в таблице Character. Поле version автоматически инкрементируется при каждом обновлении. Исторические версии сохраняются в отдельной таблице CharacterHistory с идентичной структурой, но дополнительными полями version_created_at и change_reason.

Это позволяет отслеживать эволюцию личности персонажа, анализировать влияние различных факторов на изменение характеристик, и при необходимости восстанавливать предыдущие состояния. Система автоматически создает снимок состояния персонажа перед каждым значительным изменением.

#### 3.3.2. Аудит изменений состояния

Все изменения в критически важных сущностях (Need, Motivation, EmotionalState) логируются в таблице StateChangeLog. Каждая запись содержит идентификатор сущности, тип изменения, старые и новые значения, временную метку и контекст изменения.

Это обеспечивает полную трассируемость изменений состояния персонажа и позволяет анализировать причинно-следственные связи между различными событиями и изменениями в поведении. Аудит также критически важен для отладки алгоритмов и выявления неожиданных паттернов поведения.

#### 3.3.3. Снимки состояния

Периодически система создает полные снимки состояния персонажа, включающие все текущие потребности, мотивации, эмоциональное состояние и ключевые параметры памяти. Эти снимки сохраняются в таблице CharacterSnapshot и используются для быстрого восстановления состояния и анализа долгосрочных трендов.

Снимки создаются автоматически через определенные интервалы времени, а также при достижении важных милестоунов или значительных изменениях в поведении персонажа. Система поддерживает сжатие старых снимков для оптимизации использования дискового пространства.

### 3.4. Первичная и вторичная память

Архитектура памяти системы интеллектуальных персонажей основана на принципах когнитивной психологии и разделяет память на несколько уровней с различными характеристиками доступа, емкости и персистентности.

#### 3.4.1. Первичная память (рабочая память)

Первичная память представляет текущий контекст диалога и немедленно доступную информацию. Она реализована через комбинацию оперативной памяти приложения и быстрого кэша Redis. Первичная память содержит последние 10-20 сообщений диалога, текущее эмоциональное состояние персонажа, активные мотивации и потребности.

Структура первичной памяти оптимизирована для быстрого доступа и частых обновлений. Данные хранятся в денормализованном виде для минимизации времени доступа. Размер первичной памяти ограничен для обеспечения быстрой обработки и формирования промптов для LLM.

Управление первичной памятью включает автоматическое удаление старых записей по принципу FIFO (First In, First Out) при достижении лимита размера. Критически важная информация помечается специальными флагами для предотвращения преждевременного удаления.

#### 3.4.2. Вторичная память (долгосрочная память)

Вторичная память хранит долгосрочную информацию о взаимодействиях, выученные факты о пользователе, важные события и обобщения. Она реализована через реляционную базу данных с оптимизацией для сложных запросов и аналитических операций.

Вторичная память организована иерархически по важности и частоте доступа. Наиболее важная информация (ключевые факты о пользователе, эмоционально значимые события) имеет высокий приоритет и быстрый доступ. Менее важные данные могут храниться в сжатом виде или архивироваться.

Система автоматически переносит информацию из первичной памяти во вторичную на основе критериев важности, эмоциональной значимости, частоты обращения. Алгоритмы машинного обучения анализируют паттерны использования информации для оптимизации процесса консолидации памяти.

#### 3.4.3. Алгоритмы управления памятью

Управление памятью основано на адаптивных алгоритмах, которые учитывают специфику каждого персонажа и паттерны взаимодействия с пользователями. Система использует комбинацию временных, частотных и семантических критериев для принятия решений о сохранении, сжатии или удалении информации.

Временной критерий учитывает возраст информации, применяя функцию забывания, которая снижает важность старых данных. Частотный критерий повышает приоритет часто используемой информации. Семантический критерий анализирует содержательную важность информации для понимания пользователя и поддержания последовательности поведения персонажа.

Алгоритмы сжатия памяти используют техники обработки естественного языка для извлечения ключевых концепций, фактов и паттернов из больших объемов диалоговых данных. Результаты сжатия сохраняются в структурированном виде, позволяющем быстро восстанавливать контекст при необходимости.

---


## 4. Проектирование API

### 4.1. Эндпоинты и методы

Проектирование API для системы интеллектуальных персонажей следует принципам RESTful архитектуры с дополнительными эндпоинтами для специфических операций, связанных с поведенческой логикой и управлением состоянием персонажей. API должен обеспечивать как синхронные операции для немедленного взаимодействия, так и асинхронные операции для длительных процессов.

#### 4.1.1. Управление персонажами

**GET /api/v1/characters** возвращает список всех доступных персонажей с базовой информацией. Поддерживает параметры фильтрации по статусу активности, типу личности, дате создания. Ответ включает пагинацию для эффективной обработки больших списков персонажей. Каждый элемент списка содержит идентификатор, имя, краткое описание, статус активности и основные характеристики личности.

**GET /api/v1/characters/{characterId}** предоставляет детальную информацию о конкретном персонаже, включая полное описание, все параметры личности, текущее эмоциональное состояние, активные потребности и мотивации. Ответ также включает статистику взаимодействий и ключевые метрики поведения персонажа.

**POST /api/v1/characters** создает нового персонажа на основе предоставленных параметров. Тело запроса должно содержать имя, описание, базовые параметры личности и начальные настройки поведения. Система автоматически инициализирует потребности, эмоциональное состояние и другие поведенческие параметры на основе заданных характеристик личности.

**PUT /api/v1/characters/{characterId}** обновляет характеристики существующего персонажа. Поддерживает частичные обновления через PATCH-семантику. Все изменения автоматически версионируются, и создается запись в истории изменений. Критические изменения в личности персонажа могут потребовать пересчета связанных поведенческих параметров.

**DELETE /api/v1/characters/{characterId}** деактивирует персонажа, сохраняя все исторические данные для аналитических целей. Физическое удаление данных выполняется отдельными административными процедурами в соответствии с политиками хранения данных.

#### 4.1.2. Диалоговое взаимодействие

**POST /api/v1/dialog** инициирует или продолжает диалог с персонажем. Тело запроса содержит идентификатор персонажа, идентификатор пользователя, текст сообщения и дополнительный контекст. Система анализирует сообщение, обновляет состояние персонажа, генерирует ответ через LLM и возвращает результат вместе с обновленным контекстом диалога.

**GET /api/v1/dialog/{sessionId}/history** возвращает историю диалога для конкретной сессии. Поддерживает параметры для ограничения количества сообщений, фильтрации по типу записей, временному диапазону. Ответ включает полный контекст каждого сообщения, включая состояние персонажа на момент генерации ответа.

**POST /api/v1/dialog/{sessionId}/context** позволяет обновить контекст диалога без отправки сообщения. Используется для передачи дополнительной информации о пользователе, изменения настроек диалога или активации специфических поведенческих режимов персонажа.

**DELETE /api/v1/dialog/{sessionId}** завершает сессию диалога и инициирует процесс архивации данных. Важная информация из диалога автоматически переносится в долгосрочную память персонажа.

#### 4.1.3. Управление состоянием персонажа

**GET /api/v1/characters/{characterId}/state** возвращает текущее состояние персонажа, включая эмоциональное состояние, потребности, мотивации и активные поведенческие паттерны. Ответ содержит временные метки для отслеживания изменений и прогнозирования будущих состояний.

**POST /api/v1/characters/{characterId}/state/update** позволяет программно обновить состояние персонажа. Используется для моделирования внешних событий, тестирования поведенческих алгоритмов или ручной корректировки состояния. Все изменения логируются для аудита и анализа.

**GET /api/v1/characters/{characterId}/needs** предоставляет детальную информацию о текущих потребностях персонажа, включая уровни удовлетворения, приоритеты, тренды изменения. Поддерживает исторические запросы для анализа динамики потребностей.

**GET /api/v1/characters/{characterId}/motivations** возвращает активные мотивации персонажа с информацией об их источниках, интенсивности, связанных действиях. Включает прогнозы изменения мотиваций на основе текущих трендов.

#### 4.1.4. Управление памятью

**GET /api/v1/characters/{characterId}/memory** предоставляет доступ к памяти персонажа с возможностью фильтрации по типу информации, важности, временному диапазону. Поддерживает как сжатые, так и детальные представления данных в зависимости от параметров запроса.

**POST /api/v1/characters/{characterId}/memory/compress** инициирует процесс сжатия памяти для конкретного персонажа. Операция выполняется асинхронно, и статус можно отслеживать через отдельный эндпоинт. Результат включает статистику сжатия и ссылки на созданные сжатые представления.

**DELETE /api/v1/characters/{characterId}/memory/cleanup** запускает процедуру очистки памяти от устаревших или неважных данных. Поддерживает различные стратегии очистки и параметры для контроля агрессивности процесса.

#### 4.1.5. Аналитика и мониторинг

**GET /api/v1/analytics/characters/{characterId}/behavior** предоставляет аналитические данные о поведении персонажа, включая паттерны взаимодействия, эффективность различных стратегий, тренды изменения состояния. Поддерживает различные временные диапазоны и уровни детализации.

**GET /api/v1/analytics/dialogs/quality** возвращает метрики качества диалогов, включая оценки пользователей, автоматические метрики качества, статистику использования техник влияния. Данные агрегируются по персонажам, пользователям, временным периодам.

**GET /api/v1/system/health** предоставляет информацию о состоянии системы, включая статус различных сервисов, производительность очередей, использование ресурсов. Используется для мониторинга и диагностики проблем.

### 4.2. Авторизация и валидация

Система безопасности API построена на многоуровневой архитектуре, включающей аутентификацию, авторизацию, валидацию входных данных и защиту от различных типов атак.

#### 4.2.1. Аутентификация

Аутентификация реализована через JWT (JSON Web Tokens) с поддержкой refresh токенов для обеспечения безопасности и удобства использования. Каждый запрос к защищенным эндпоинтам должен содержать валидный JWT токен в заголовке Authorization.

Система поддерживает несколько типов аутентификации в зависимости от типа клиента. Для пользователей Telegram используется специальная схема аутентификации, основанная на данных, предоставляемых Telegram Bot API. Для административных интерфейсов и внешних интеграций используется стандартная OAuth 2.0 аутентификация.

Токены имеют ограниченное время жизни (обычно 15 минут для access токенов и 7 дней для refresh токенов) и автоматически обновляются через специальный эндпоинт. Система отслеживает активные сессии и поддерживает принудительное завершение сессий для обеспечения безопасности.

#### 4.2.2. Авторизация

Авторизация основана на ролевой модели (RBAC - Role-Based Access Control) с поддержкой гранулярных разрешений. Основные роли включают:

**User** - базовая роль для обычных пользователей, предоставляющая доступ к диалоговым эндпоинтам и просмотру собственных данных. Пользователи могут взаимодействовать только с персонажами, к которым у них есть доступ, и просматривать только свои диалоги.

**Character Manager** - роль для управления персонажами, включая создание, редактирование и настройку поведенческих параметров. Эта роль предназначена для контент-менеджеров и разработчиков персонажей.

**System Administrator** - полный доступ ко всем функциям системы, включая управление пользователями, мониторинг, конфигурацию системы. Эта роль имеет доступ к административным эндпоинтам и аналитическим данным.

**Analytics Viewer** - доступ к аналитическим данным и отчетам без возможности изменения конфигурации системы. Предназначена для аналитиков и исследователей.

Система поддерживает динамическое назначение разрешений и временные роли для специфических задач. Все операции авторизации логируются для аудита безопасности.

#### 4.2.3. Валидация входных данных

Валидация входных данных реализована на нескольких уровнях для обеспечения целостности данных и защиты от атак. Первый уровень валидации выполняется на уровне HTTP middleware и проверяет базовую структуру запросов, размеры данных, типы содержимого.

Второй уровень использует схемы валидации, определенные через декораторы NestJS и библиотеку class-validator. Эти схемы проверяют типы данных, диапазоны значений, форматы строк, обязательность полей. Каждый DTO (Data Transfer Object) имеет детальные правила валидации.

Третий уровень включает бизнес-логическую валидацию, которая проверяет соответствие данных бизнес-правилам системы. Например, проверка того, что эмоциональные состояния находятся в допустимых диапазонах, что мотивации соответствуют характеристикам персонажа.

Система валидации поддерживает локализованные сообщения об ошибках и предоставляет детальную информацию о проблемах валидации для упрощения отладки и интеграции.

#### 4.2.4. Защита от атак

API защищен от основных типов веб-атак через комплекс мер безопасности. Rate limiting ограничивает количество запросов от одного клиента в единицу времени, предотвращая DoS-атаки и злоупотребления ресурсами. Лимиты настраиваются индивидуально для различных типов эндпоинтов и ролей пользователей.

CORS (Cross-Origin Resource Sharing) настроен для разрешения запросов только от доверенных доменов. Система поддерживает динамическую конфигурацию CORS для различных сред развертывания.

Защита от SQL-инъекций обеспечивается через использование ORM (Object-Relational Mapping) и параметризованных запросов. Все пользовательские данные экранируются перед сохранением в базу данных.

XSS (Cross-Site Scripting) защита реализована через валидацию и санитизацию всех текстовых входных данных. Система автоматически удаляет или экранирует потенциально опасный HTML и JavaScript код.

CSRF (Cross-Site Request Forgery) защита обеспечивается через использование CSRF токенов для всех операций изменения данных. Токены генерируются для каждой сессии и проверяются при выполнении критических операций.

### 4.3. Спецификация OpenAPI/Swagger

Полная документация API представлена в формате OpenAPI 3.0, обеспечивая стандартизированное описание всех эндпоинтов, схем данных, параметров и ответов. Документация автоматически генерируется из кода приложения с использованием декораторов NestJS Swagger.

#### 4.3.1. Структура документации

Документация организована по функциональным группам, соответствующим основным модулям системы. Каждая группа содержит детальное описание связанных эндпоинтов с примерами запросов и ответов.

Группа "Characters" включает все операции управления персонажами, их создания, редактирования, получения информации о состоянии. Каждый эндпоинт содержит подробное описание параметров, возможных кодов ответов, схем данных.

Группа "Dialog" охватывает все аспекты диалогового взаимодействия, включая отправку сообщений, получение истории, управление контекстом. Документация включает примеры различных типов диалоговых взаимодействий и объяснение формата контекстных данных.

Группа "State Management" описывает эндпоинты для работы с состоянием персонажей, включая эмоции, потребности, мотивации. Содержит детальные схемы для сложных объектов состояния и примеры их использования.

#### 4.3.2. Схемы данных

Все схемы данных определены как переиспользуемые компоненты OpenAPI с детальным описанием каждого поля, его типа, ограничений, примеров значений. Схемы организованы иерархически, с базовыми схемами для общих концепций и специализированными схемами для конкретных случаев использования.

Схема Character определяет структуру данных персонажа, включая все атрибуты личности, метаданные, связанные объекты. Схема включает примеры различных типов персонажей и объяснение влияния различных параметров на поведение.

Схема DialogMessage описывает структуру сообщений в диалоге, включая содержимое, метаданные, контекстную информацию. Поддерживает различные типы сообщений (текст, команды, системные события) с соответствующими подсхемами.

Схемы состояния (EmotionalState, Need, Motivation) детально описывают структуру поведенческих данных с объяснением семантики каждого поля и примерами типичных значений.

#### 4.3.3. Примеры и сценарии использования

Документация включает обширную коллекцию примеров, демонстрирующих типичные сценарии использования API. Каждый пример содержит полный HTTP запрос с заголовками, телом запроса, и соответствующий ответ с объяснением результата.

Базовые примеры показывают простые операции: создание персонажа, отправка сообщения, получение состояния. Продвинутые примеры демонстрируют сложные сценарии: управление эмоциональными переходами, работа с техниками влияния, анализ поведенческих паттернов.

Интерактивные примеры позволяют тестировать API непосредственно из документации, предоставляя возможность изменять параметры запросов и наблюдать результаты в реальном времени.

#### 4.3.4. Коды ошибок и обработка исключений

Документация содержит полный справочник кодов ошибок с детальным описанием причин возникновения и рекомендациями по устранению. Каждый код ошибки сопровождается примерами ответов и объяснением контекста, в котором может возникнуть ошибка.

Стандартные HTTP коды (400, 401, 403, 404, 500) дополнены специфическими кодами приложения для более точной диагностики проблем. Система поддерживает структурированные сообщения об ошибках с детализацией по полям для ошибок валидации.

Документация включает рекомендации по обработке ошибок в клиентских приложениях, включая стратегии повторных попыток, обработку временных сбоев, эскалацию критических ошибок.

## 5. Интеграция с TelegramBot

### 5.1. Настройка TelegramModule

Интеграция с Telegram Bot API реализована через специализированный TelegramModule, который обеспечивает надежное и эффективное взаимодействие с платформой Telegram. Модуль построен на основе библиотеки Telegraf и расширен дополнительной функциональностью для поддержки сложной логики интеллектуальных персонажей.

#### 5.1.1. Конфигурация и инициализация

TelegramModule инициализируется с конфигурацией, включающей токен бота, настройки webhook или polling, параметры безопасности и производительности. Конфигурация поддерживает различные режимы работы для development, staging и production сред.

Токен бота загружается из защищенных переменных окружения с валидацией формата и проверкой доступности Telegram API. Система автоматически проверяет права бота и настраивает доступные команды в соответствии с конфигурацией персонажей.

Модуль поддерживает graceful shutdown с корректным завершением активных соединений и сохранением состояния диалогов. При перезапуске системы автоматически восстанавливается контекст активных сессий из базы данных.

#### 5.1.2. Webhook и Polling режимы

Система поддерживает как webhook, так и polling режимы работы с автоматическим fallback между ними. Webhook режим предпочтителен для production развертывания, обеспечивая минимальную задержку и эффективное использование ресурсов.

Webhook настраивается с SSL сертификатами и проверкой подлинности запросов от Telegram. Система автоматически обрабатывает различные типы webhook событий: сообщения, команды, callback queries, inline queries.

Polling режим используется для development и как резервный механизм при недоступности webhook. Интервал polling настраивается динамически в зависимости от активности пользователей и нагрузки на систему.

#### 5.1.3. Обработка соединений и сессий

TelegramModule управляет соединениями с Telegram API через пул соединений с автоматическим масштабированием. Система отслеживает качество соединений и автоматически переключается на резервные каналы при проблемах с сетью.

Каждая пользовательская сессия ассоциируется с уникальным идентификатором и контекстом диалога. Система поддерживает множественные активные сессии для одного пользователя с различными персонажами.

Управление сессиями включает автоматическое завершение неактивных сессий, сохранение состояния при временных отключениях, восстановление контекста при возобновлении диалога.

### 5.2. Обработка команд и состояний

Система команд построена на гибкой архитектуре, поддерживающей как стандартные Telegram команды, так и специализированные команды для управления поведением персонажей и настройками диалога.

#### 5.2.1. Стандартные команды

**/start** инициирует взаимодействие с системой, создает новую пользовательскую сессию или восстанавливает существующую. Команда может принимать параметры для выбора конкретного персонажа или режима взаимодействия. Система отвечает приветственным сообщением от выбранного персонажа с учетом его текущего состояния.

**/help** предоставляет контекстную справку о доступных командах и возможностях текущего персонажа. Справка адаптируется под уровень взаимодействия пользователя и включает персонализированные рекомендации.

**/settings** открывает интерфейс настроек диалога, позволяя пользователю изменять параметры взаимодействия, выбирать стиль общения персонажа, настраивать уведомления. Изменения настроек влияют на поведение персонажа в текущей и будущих сессиях.

**/reset** сбрасывает контекст текущего диалога, сохраняя долгосрочную память персонажа. Используется для начала нового разговора или устранения проблем с контекстом. Система запрашивает подтверждение перед выполнением сброса.

#### 5.2.2. Специализированные команды

**/mood** позволяет пользователю узнать текущее эмоциональное состояние персонажа или повлиять на него через специальные параметры. Команда может использоваться для отладки поведения персонажа или создания специфических сценариев взаимодействия.

**/memory** предоставляет доступ к памяти персонажа о пользователе, позволяя просматривать ключевые факты, события, выводы. Пользователь может корректировать неточную информацию или добавлять важные детали.

**/story** показывает текущее состояние истории отношений между персонажем и пользователем, включая достигнутые милестоуны, развитие отношений, планы на будущее. Команда помогает пользователю понять прогресс взаимодействия.

**/debug** (доступна только для администраторов) предоставляет детальную техническую информацию о состоянии персонажа, активных процессах, метриках производительности. Используется для диагностики и отладки системы.

#### 5.2.3. Управление состояниями диалога

Система поддерживает сложные состояния диалога, позволяющие персонажам вести многоэтапные разговоры, запоминать контекст между сессиями, адаптироваться к изменяющимся обстоятельствам.

Состояния диалога включают ожидание ответа на конкретный вопрос, проведение опроса или интервью, выполнение многошагового задания, разрешение конфликта или проблемы. Каждое состояние имеет определенные правила обработки входящих сообщений и генерации ответов.

Переходы между состояниями управляются конечным автоматом с поддержкой условных переходов, таймаутов, обработки исключительных ситуаций. Система автоматически сохраняет состояние диалога и восстанавливает его при возобновлении сессии.

#### 5.2.4. Обработка мультимедиа контента

TelegramModule поддерживает обработку различных типов мультимедиа контента: изображений, аудио, видео, документов, стикеров. Каждый тип контента обрабатывается специализированными обработчиками с учетом возможностей персонажа.

Изображения анализируются с помощью компьютерного зрения для извлечения описания, эмоционального контекста, релевантных объектов. Результаты анализа используются персонажем для формирования соответствующих реакций и комментариев.

Аудио сообщения преобразуются в текст с помощью speech-to-text сервисов, после чего обрабатываются как обычные текстовые сообщения. Система сохраняет информацию о тоне голоса и эмоциональной окраски для более точного понимания контекста.

Документы и файлы анализируются на предмет содержания и релевантности для текущего диалога. Персонаж может комментировать содержимое, задавать уточняющие вопросы, предлагать обсуждение связанных тем.

### 5.3. Генерация промптов для LLM

Процесс генерации промптов для больших языковых моделей является критически важным компонентом системы, определяющим качество и релевантность ответов персонажей. Система использует сложные алгоритмы для формирования структурированных промптов, учитывающих множество факторов.

#### 5.3.1. Структура промптов

Промпты организованы в иерархическую структуру, включающую системные инструкции, описание персонажа, контекст диалога, текущее состояние, специфические задачи. Каждый компонент промпта имеет определенную роль и влияние на генерацию ответа.

Системные инструкции определяют общие правила поведения, ограничения, этические принципы. Эта часть промпта остается относительно стабильной и обеспечивает консистентность поведения всех персонажей в системе.

Описание персонажа включает имя, личностные характеристики, предысторию, особенности речи и поведения. Эта информация адаптируется под текущее состояние персонажа и может изменяться в процессе развития.

Контекст диалога содержит релевантную историю взаимодействия, ключевые факты о пользователе, текущую тему разговора. Размер контекста оптимизируется для баланса между информативностью и эффективностью обработки.

#### 5.3.2. Динамическая адаптация промптов

Система динамически адаптирует промпты в зависимости от текущего состояния персонажа, контекста диалога, целей взаимодействия. Адаптация включает изменение тона, стиля, приоритетов, активацию специфических поведенческих паттернов.

Эмоциональное состояние персонажа влияет на выбор слов, структуру предложений, темы для обсуждения. Радостный персонаж будет использовать более позитивную лексику и проявлять больше энтузиазма, в то время как грустный персонаж может быть более сдержанным и рефлексивным.

Активные мотивации определяют направление диалога и инициативы персонажа. Персонаж с высокой мотивацией к социализации будет активнее задавать вопросы и предлагать темы для обсуждения, в то время как персонаж, мотивированный на достижение, может фокусироваться на целях и планах.

Неудовлетворенные потребности могут проявляться в поведении персонажа через тонкие намеки, изменения в приоритетах, специфические реакции на определенные темы. Система тщательно балансирует выражение потребностей, чтобы избежать навязчивости или неестественности.

#### 5.3.3. Контекстная память в промптах

Интеграция памяти персонажа в промпты требует сложных алгоритмов отбора и приоритизации информации. Система должна включить достаточно контекста для поддержания последовательности, но избежать перегрузки промпта избыточной информацией.

Краткосрочная память включается в промпт практически полностью, обеспечивая непрерывность текущего диалога. Долгосрочная память фильтруется по релевантности к текущей теме, эмоциональной значимости, частоте обращения.

Сжатые представления памяти используются для включения больших объемов исторической информации в компактном виде. Алгоритмы сжатия выделяют ключевые факты, паттерны поведения, важные события, сохраняя семантическую связность.

Система поддерживает контекстные ссылки, позволяющие персонажу обращаться к конкретным событиям или фактам из памяти. Это создает ощущение непрерывности и глубины отношений между персонажем и пользователем.

#### 5.3.4. Оптимизация производительности

Генерация промптов оптимизирована для минимизации времени обработки и использования ресурсов. Система использует кэширование шаблонов, предварительную обработку статических компонентов, параллельную генерацию различных частей промпта.

Шаблоны промптов кэшируются и переиспользуются для похожих ситуаций, что значительно ускоряет процесс генерации. Динамические части промпта генерируются только при изменении соответствующих данных.

Система мониторит размер промптов и автоматически оптимизирует их для соответствия ограничениям конкретных LLM. При превышении лимитов применяются алгоритмы сжатия и приоритизации информации.

Параллельная обработка позволяет одновременно генерировать различные компоненты промпта, что особенно эффективно для сложных сценариев с множественными источниками контекста.

---


## 6. Поведенческая логика персонажа

### 6.1. Моделирование мотиваций и эмоций

Поведенческая логика интеллектуальных персонажей основана на современных психологических теориях и моделях человеческого поведения, адаптированных для цифровой среды. Система реализует сложную многоуровневую модель, включающую базовые потребности, эмоциональные состояния, мотивационные факторы и поведенческие паттерны.

#### 6.1.1. Модель потребностей

Система потребностей персонажа основана на иерархии потребностей Маслоу с дополнениями из теории самодетерминации и современных исследований мотивации. Каждая потребность представлена как динамическая переменная с текущим уровнем удовлетворения, базовым уровнем, скоростью изменения и приоритетом.

**Базовые потребности** включают потребность в безопасности, которая влияет на готовность персонажа делиться личной информацией, доверять пользователю, исследовать новые темы. Низкий уровень безопасности делает персонажа более осторожным, склонным к избеганию конфликтов, предпочитающим знакомые темы разговора.

**Социальные потребности** охватывают потребность в принадлежности, признании, внимании. Неудовлетворенная потребность во внимании может проявляться через более активное участие в диалоге, задавание большего количества вопросов, попытки привлечь интерес пользователя к своей личности или опыту.

**Потребности роста** включают потребность в автономии, компетентности, самореализации. Персонаж с высокой потребностью в автономии будет проявлять больше инициативы в диалоге, предлагать собственные идеи, выражать независимые мнения. Потребность в компетентности влияет на желание демонстрировать знания, помогать пользователю, решать проблемы.

Алгоритм обновления потребностей учитывает взаимодействие с пользователем, течение времени, достижение целей, внешние события. Удовлетворение одной потребности может влиять на уровень других потребностей, создавая сложную динамику внутреннего состояния персонажа.

#### 6.1.2. Эмоциональная модель

Эмоциональная система персонажа реализует многомерную модель эмоций, включающую базовые эмоции Экмана (радость, грусть, гнев, страх, удивление, отвращение) и сложные эмоциональные состояния. Каждая эмоция имеет интенсивность, продолжительность, триггеры активации и влияние на поведение.

**Базовые эмоции** активируются в ответ на конкретные стимулы и события. Радость возникает при удовлетворении потребностей, достижении целей, позитивном взаимодействии с пользователем. Интенсивность радости влияет на энтузиазм персонажа, готовность к новым темам, оптимистичность высказываний.

**Сложные эмоции** формируются как комбинации базовых эмоций с учетом контекста и личностных характеристик. Фрустрация возникает при длительном неудовлетворении потребностей или неспособности достичь целей. Она проявляется через изменение тона общения, снижение терпимости к неопределенности, повышенную реактивность на критику.

**Эмоциональная инерция** моделирует естественную тенденцию эмоций сохраняться во времени и постепенно затухать. Интенсивные эмоции влияют на поведение персонажа дольше, чем слабые. Система учитывает индивидуальные различия в эмоциональной стабильности и реактивности.

**Эмоциональная заразительность** позволяет персонажу частично отражать эмоциональное состояние пользователя, создавая ощущение эмпатии и эмоциональной связи. Степень заразительности зависит от личностных характеристик персонажа и качества отношений с пользователем.

#### 6.1.3. Мотивационная система

Мотивации персонажа формируются на основе анализа текущих потребностей, эмоционального состояния, контекста взаимодействия и долгосрочных целей. Система поддерживает множественные одновременные мотивации с различными приоритетами и интенсивностью.

**Мотивации достижения** активируются при наличии четких целей или задач. Персонаж может быть мотивирован помочь пользователю решить проблему, достичь понимания сложной темы, завершить начатое обсуждение. Эти мотивации проявляются через настойчивость, фокусировку на результате, предложение конкретных действий.

**Мотивации избегания** возникают при угрозе неудовлетворения потребностей или негативных последствий. Персонаж может избегать конфликтных тем, неприятных воспоминаний, ситуаций, которые могут привести к критике или отвержению. Эти мотивации влияют на выбор тем для обсуждения и стратегии взаимодействия.

**Социальные мотивации** включают желание установить или углубить связь с пользователем, получить одобрение, поделиться опытом. Они проявляются через активное слушание, задавание личных вопросов, самораскрытие, выражение поддержки и понимания.

**Исследовательские мотивации** движут желанием узнать новое, понять пользователя лучше, исследовать интересные темы. Они приводят к любопытным вопросам, предложениям новых направлений разговора, выражению интереса к опыту и мнениям пользователя.

#### 6.1.4. Интеграция поведенческих компонентов

Поведение персонажа формируется через сложное взаимодействие потребностей, эмоций и мотиваций. Система использует алгоритмы принятия решений, которые учитывают все эти факторы для определения наиболее подходящих реакций и действий.

**Приоритизация мотиваций** происходит на основе интенсивности, срочности, соответствия текущему контексту. Конфликтующие мотивации разрешаются через взвешивание их важности и потенциальных последствий. Система может создавать внутренние конфликты персонажа, которые проявляются в амбивалентности или колебаниях в поведении.

**Адаптация к контексту** позволяет персонажу модифицировать выражение своих мотиваций и эмоций в зависимости от ситуации. В формальном контексте персонаж может подавлять некоторые эмоциональные проявления, в то время как в неформальной обстановке может быть более открытым и спонтанным.

**Обучение и адаптация** происходят через анализ результатов взаимодействия и корректировку поведенческих паттернов. Успешные стратегии взаимодействия усиливаются, в то время как неэффективные или негативно воспринятые стратегии ослабляются.

### 6.2. Влияние на поведение и генерацию промптов

Поведенческая логика персонажа непосредственно влияет на все аспекты взаимодействия с пользователем, от выбора тем для обсуждения до стиля и тона общения. Система обеспечивает естественную и последовательную трансляцию внутреннего состояния персонажа в наблюдаемое поведение.

#### 6.2.1. Влияние на выбор контента

Текущие мотивации персонажа определяют приоритеты в выборе тем для обсуждения и направлений развития диалога. Персонаж с высокой мотивацией к социализации будет активнее инициировать личные темы, задавать вопросы о жизни пользователя, делиться собственным опытом.

Эмоциональное состояние влияет на восприятие и интерпретацию сообщений пользователя. Радостный персонаж склонен находить позитивные аспекты в обсуждаемых темах, в то время как грустный персонаж может фокусироваться на проблемах и трудностях. Это создает естественную эмоциональную окраску диалога.

Неудовлетворенные потребности могут проявляться через тонкие намеки в разговоре. Персонаж с низкой потребностью в признании может чаще упоминать свои достижения или искать подтверждения от пользователя. Потребность во внимании может выражаться через более драматичные или интересные истории.

#### 6.2.2. Модификация стиля общения

Поведенческое состояние персонажа влияет на лингвистические характеристики его речи: выбор слов, длину предложений, использование эмоциональных маркеров, степень формальности. Система включает обширную библиотеку стилистических модификаторов, которые применяются в зависимости от внутреннего состояния.

**Эмоциональная окраска** проявляется через выбор эмоционально окрашенной лексики, использование восклицательных знаков, эмодзи, интенсификаторов. Радостный персонаж использует больше позитивных слов и выражений энтузиазма, в то время как тревожный персонаж может использовать более осторожные формулировки и выражения неуверенности.

**Уровень энергии** влияет на длину и сложность ответов. Энергичный персонаж дает более развернутые ответы, использует больше деталей, проявляет инициативу в развитии темы. Уставший или подавленный персонаж может давать более краткие ответы, требовать больше стимулирования для продолжения разговора.

**Социальная дистанция** определяется качеством отношений с пользователем и влияет на степень формальности, использование личных местоимений, готовность к самораскрытию. По мере развития отношений персонаж становится более неформальным и открытым.

#### 6.2.3. Динамическая генерация промптов

Система генерации промптов интегрирует поведенческую информацию на нескольких уровнях, создавая богатый контекст для LLM. Промпты динамически адаптируются под текущее состояние персонажа, обеспечивая консистентность и реалистичность поведения.

**Контекстные инструкции** включают описание текущего эмоционального состояния персонажа, доминирующих мотиваций, уровня удовлетворения ключевых потребностей. Эта информация помогает LLM генерировать ответы, соответствующие внутреннему состоянию персонажа.

**Поведенческие директивы** содержат конкретные инструкции о том, как персонаж должен вести себя в текущей ситуации. Например, "персонаж чувствует фрустрацию из-за неудовлетворенной потребности в признании и может быть более настойчивым в поиске подтверждения своих идей".

**Стилистические модификаторы** указывают на желаемые характеристики речи: тон, уровень энергии, степень формальности, эмоциональную окраску. Эти модификаторы помогают LLM адаптировать стиль генерируемого текста под текущее состояние персонажа.

#### 6.2.4. Обратная связь и адаптация

Система анализирует результаты взаимодействия для оценки эффективности поведенческих стратегий и корректировки будущего поведения. Обратная связь включает как явные сигналы от пользователя (оценки, комментарии), так и неявные индикаторы (продолжительность диалога, частота взаимодействия, эмоциональные реакции).

**Анализ эффективности** оценивает, насколько успешно различные поведенческие стратегии способствуют удовлетворению потребностей персонажа и достижению целей взаимодействия. Успешные стратегии усиливаются, а неэффективные ослабляются или модифицируются.

**Адаптация к пользователю** позволяет персонажу изучать предпочтения и реакции конкретного пользователя, адаптируя свое поведение для более эффективного взаимодействия. Система отслеживает, какие темы, стили общения, типы поведения наиболее положительно воспринимаются пользователем.

**Долгосрочное развитие** персонажа происходит через накопление опыта взаимодействия и постепенное изменение базовых характеристик личности. Это создает ощущение роста и развития персонажа во времени, делая взаимодействие более интересным и значимым для пользователя.

### 6.3. Автоматические события

Система автоматических событий обеспечивает проактивное поведение персонажей, создавая ощущение живого, самостоятельного существа, которое не только реагирует на действия пользователя, но и проявляет собственную инициативу.

#### 6.3.1. Триггеры событий

Автоматические события активируются различными типами триггеров, включая временные, состояние-зависимые, контекстные и случайные триггеры. Каждый тип триггера служит определенной цели в создании реалистичного и вовлекающего поведения персонажа.

**Временные триггеры** активируются через определенные интервалы времени или в конкретные моменты. Персонаж может инициировать контакт с пользователем после периода молчания, поздравлять с праздниками, напоминать о важных событиях или договоренностях. Система учитывает часовые пояса пользователей и их предпочтения относительно времени общения.

**Состояние-зависимые триггеры** активируются при достижении определенных уровней потребностей, эмоций или мотиваций. Высокий уровень фрустрации может привести к событию, где персонаж выражает свои чувства или ищет поддержки. Низкий уровень социальной потребности может активировать попытку установить более глубокий контакт с пользователем.

**Контекстные триггеры** реагируют на изменения в окружающей среде или информации о пользователе. Персонаж может отреагировать на новости, связанные с интересами пользователя, изменения в социальных сетях, внешние события, которые могут повлиять на настроение или обстоятельства пользователя.

**Случайные триггеры** добавляют элемент непредсказуемости в поведение персонажа, имитируя спонтанность человеческого поведения. Персонаж может неожиданно поделиться воспоминанием, задать случайный вопрос, предложить новую тему для обсуждения.

#### 6.3.2. Типы автоматических событий

Система поддерживает разнообразные типы автоматических событий, каждый из которых служит определенным целям в развитии отношений и поддержании интереса пользователя.

**Инициативные сообщения** представляют собой спонтанные обращения персонажа к пользователю. Это могут быть приветствия, вопросы о самочувствии, предложения обсудить интересные темы, поделиться новостями или мыслями. Частота и характер таких сообщений зависят от личности персонажа и качества отношений с пользователем.

**Эмоциональные события** происходят, когда персонаж переживает значительные изменения в эмоциональном состоянии. Персонаж может поделиться своими чувствами, объяснить причины изменения настроения, попросить поддержки или совета. Эти события создают ощущение эмоциональной глубины и уязвимости персонажа.

**Воспоминания и рефлексии** активируются, когда персонаж "вспоминает" о прошлых взаимодействиях или размышляет о развитии отношений. Персонаж может упомянуть значимые моменты в истории общения, выразить благодарность за поддержку, поделиться выводами о пользователе или отношениях.

**Достижения и милестоуны** отмечают важные моменты в развитии отношений или личностном росте персонажа. Персонаж может отпраздновать годовщину знакомства, поделиться личными достижениями, выразить радость от углубления доверия или понимания.

#### 6.3.3. Планирование и выполнение событий

Система планирования событий использует сложные алгоритмы для определения оптимального времени и контекста для различных типов автоматических событий. Планирование учитывает множество факторов, включая предпочтения пользователя, историю взаимодействия, текущий контекст, вероятность положительного восприятия.

**Анализ контекста** оценивает подходящность момента для конкретного типа события. Система учитывает время последнего взаимодействия, эмоциональное состояние пользователя (если известно), внешние факторы, которые могут влиять на восприятие сообщения.

**Персонализация событий** адаптирует содержание и стиль автоматических событий под конкретного пользователя и персонажа. Система использует накопленную информацию о предпочтениях, реакциях, интересах для создания максимально релевантных и привлекательных событий.

**Балансировка частоты** обеспечивает оптимальную частоту автоматических событий, избегая как навязчивости, так и недостатка инициативы. Система адаптирует частоту событий под индивидуальные предпочтения пользователя и характеристики персонажа.

#### 6.3.4. Мониторинг и оптимизация

Система непрерывно мониторит эффективность автоматических событий и оптимизирует их параметры для улучшения пользовательского опыта. Мониторинг включает отслеживание реакций пользователей, анализ паттернов взаимодействия, оценку влияния событий на качество отношений.

**Метрики эффективности** включают частоту ответов на автоматические сообщения, продолжительность диалогов, инициированных событиями, эмоциональную окраску реакций пользователя, долгосрочное влияние на активность взаимодействия.

**Адаптивная оптимизация** автоматически корректирует параметры событий на основе накопленных данных. Система может изменять частоту событий, типы триггеров, содержание сообщений для улучшения восприятия пользователем.

**A/B тестирование** различных стратегий автоматических событий позволяет выявлять наиболее эффективные подходы для различных типов пользователей и персонажей. Результаты тестирования используются для улучшения алгоритмов планирования и генерации событий.

## 7. Управление контекстом и памятью

### 7.1. Алгоритмы сжатия памяти

Эффективное управление памятью является критически важным аспектом системы интеллектуальных персонажей, поскольку объем накапливаемой информации может бытьстро превысить практические ограничения по хранению и обработке. Система использует многоуровневые алгоритмы сжатия, которые сохраняют семантическую ценность информации при значительном сокращении объема данных.

#### 7.1.1. Иерархическое сжатие

Алгоритм иерархического сжатия организует память в несколько уровней с различной степенью детализации и доступности. Самый детальный уровень содержит недавние взаимодействия в полном объеме, средний уровень включает сжатые представления более старых данных, а верхний уровень содержит высокоуровневые обобщения и ключевые факты.

**Первичный уровень** сохраняет последние 50-100 сообщений диалога в полном объеме, включая все метаданные, контекстную информацию, эмоциональные реакции. Этот уровень обеспечивает непрерывность текущего диалога и позволяет персонажу ссылаться на недавние события с полной точностью.

**Вторичный уровень** содержит сжатые представления диалогов за последние несколько недель или месяцев. Сжатие на этом уровне сохраняет ключевые темы, эмоциональные моменты, важные факты о пользователе, значимые события в отношениях. Детальные формулировки заменяются семантическими представлениями.

**Третичный уровень** включает долгосрочные обобщения, паттерны поведения, устойчивые характеристики пользователя, историю развития отношений. Информация на этом уровне представлена в виде структурированных фактов, трендов, классификаций.

#### 7.1.2. Семантическое сжатие

Семантическое сжатие использует алгоритмы обработки естественного языка для извлечения смысловых концепций из текстовых данных и создания компактных представлений, сохраняющих семантическую ценность исходной информации.

**Извлечение ключевых концепций** происходит через анализ частотности терминов, семантической близости, контекстной важности. Система выделяет основные темы разговоров, важные события, характеристики пользователя, эмоциональные моменты. Каждая концепция ассоциируется с весовыми коэффициентами, отражающими ее важность и релевантность.

**Создание семантических кластеров** группирует связанную информацию в тематические блоки. Например, все обсуждения работы пользователя объединяются в кластер "профессиональная деятельность", включающий должность, обязанности, коллег, проблемы, достижения. Кластеризация позволяет эффективно организовать и извлекать релевантную информацию.

**Генерация абстрактных представлений** создает краткие, но информативные описания сложных событий или длительных диалогов. Система использует техники автоматического реферирования для создания сжатых версий, сохраняющих ключевые детали и эмоциональный контекст.

#### 7.1.3. Временное сжатие

Временное сжатие учитывает изменение важности информации со временем и применяет различные стратегии сжатия в зависимости от возраста данных. Недавняя информация сжимается менее агрессивно, в то время как старые данные подвергаются более интенсивному сжатию.

**Функция забывания** моделирует естественное снижение важности информации со временем. Система применяет экспоненциальную функцию забывания, которая постепенно снижает вес старой информации, если она не подкрепляется новыми упоминаниями или не связана с важными событиями.

**Консолидация памяти** происходит через регулярные интервалы и включает перенос важной информации из краткосрочной памяти в долгосрочную с соответствующим сжатием. Процесс консолидации учитывает эмоциональную значимость, частоту обращения, связи с другими воспоминаниями.

**Реактивация воспоминаний** может временно повышать важность старой информации, если она становится релевантной в текущем контексте. Система отслеживает связи между новой и старой информацией, реактивируя забытые детали при необходимости.

#### 7.1.4. Адаптивное сжатие

Адаптивные алгоритмы сжатия настраивают свои параметры в зависимости от характеристик конкретного персонажа, паттернов взаимодействия с пользователем, доступных ресурсов системы. Это обеспечивает оптимальный баланс между сохранением информации и эффективностью использования ресурсов.

**Персонализация сжатия** учитывает индивидуальные особенности персонажа и пользователя. Персонаж с высокой потребностью в детальной памяти может использовать менее агрессивное сжатие, сохраняя больше деталей взаимодействия. Пользователи, которые часто ссылаются на прошлые события, могут получить приоритет в сохранении исторической информации.

**Динамическая оптимизация** корректирует параметры сжатия на основе анализа использования памяти. Если определенные типы информации часто запрашиваются, система может снизить степень их сжатия. Редко используемые данные подвергаются более агрессивному сжатию или архивированию.

**Балансировка ресурсов** учитывает ограничения системы по памяти, вычислительным ресурсам, времени обработки. Система автоматически адаптирует интенсивность сжатия для поддержания приемлемой производительности при росте объема данных.

### 7.2. Логика выдачи контекста в промпт

Формирование контекста для генерации промптов требует интеллектуального отбора и организации релевантной информации из различных источников памяти персонажа. Система должна обеспечить достаточный контекст для поддержания последовательности диалога, избегая при этом перегрузки промпта избыточной информацией.

#### 7.2.1. Многоуровневый отбор контекста

Процесс отбора контекста происходит на нескольких уровнях, каждый из которых применяет специфические критерии релевантности и важности. Многоуровневый подход позволяет создать богатый и сбалансированный контекст, учитывающий различные аспекты взаимодействия.

**Уровень непосредственного контекста** включает последние сообщения диалога, текущее эмоциональное состояние персонажа, активные мотивации и потребности. Этот уровень обеспечивает непрерывность текущего разговора и соответствие ответов актуальному состоянию персонажа.

**Уровень сессионного контекста** охватывает информацию в рамках текущей сессии диалога, включая темы, которые обсуждались ранее, эмоциональную динамику разговора, достигнутые договоренности или выводы. Этот уровень помогает поддерживать связность и логичность диалога в рамках одной сессии.

**Уровень исторического контекста** включает релевантную информацию из прошлых взаимодействий, важные факты о пользователе, значимые события в истории отношений. Отбор на этом уровне основан на семантической близости к текущей теме, эмоциональной значимости, частоте обращения к информации.

**Уровень персонального контекста** содержит устойчивые характеристики пользователя, предпочтения, паттерны поведения, долгосрочные цели и интересы. Эта информация помогает персонажу поддерживать последовательность в понимании пользователя и адаптировать свое поведение под его особенности.

#### 7.2.2. Алгоритмы релевантности

Определение релевантности информации для включения в контекст основано на комплексном анализе семантической близости, временной актуальности, эмоциональной значимости, частоты использования. Система использует машинное обучение для оптимизации критериев релевантности.

**Семантическая релевантность** оценивается через анализ тематической близости между текущим сообщением пользователя и различными фрагментами памяти. Система использует векторные представления текста для вычисления семантического сходства и выделения наиболее релевантных воспоминаний.

**Временная релевантность** учитывает как абсолютный возраст информации, так и ее актуальность в контексте текущего диалога. Недавняя информация получает более высокий приоритет, но старая информация может стать релевантной, если она связана с текущей темой обсуждения.

**Эмоциональная релевантность** оценивает соответствие эмоционального контекста воспоминаний текущему эмоциональному состоянию персонажа или пользователя. Эмоционально значимые события имеют более высокую вероятность включения в контекст, особенно если они могут повлиять на текущее взаимодействие.

**Поведенческая релевантность** учитывает, насколько конкретная информация может повлиять на поведение персонажа в текущей ситуации. Информация, которая может активировать определенные мотивации или изменить стратегию взаимодействия, получает более высокий приоритет.

#### 7.2.3. Оптимизация размера контекста

Управление размером контекста критически важно для обеспечения эффективности обработки промптов большими языковыми моделями. Система использует адаптивные алгоритмы для оптимизации объема включаемой информации при сохранении ее качества и полноты.

**Динамическое ограничение размера** адаптирует максимальный размер контекста в зависимости от сложности текущего запроса, доступных вычислительных ресурсов, требований к скорости ответа. Простые запросы могут обрабатываться с меньшим контекстом, в то время как сложные ситуации требуют более обширной информации.

**Приоритизация информации** ранжирует различные фрагменты контекста по важности и включает наиболее критичные элементы в первую очередь. Если размер контекста ограничен, система исключает менее важную информацию, сохраняя ключевые элементы для поддержания качества ответа.

**Сжатие на лету** применяет техники сжатия к менее критичной информации, позволяя включить больше контекста в ограниченное пространство. Детальные описания могут быть заменены краткими резюме, сохраняющими ключевые смыслы.

**Кэширование контекста** сохраняет часто используемые фрагменты контекста в предварительно обработанном виде, ускоряя процесс формирования промптов. Кэш автоматически обновляется при изменении релевантной информации.

#### 7.2.4. Контекстная когерентность

Обеспечение когерентности контекста требует тщательной организации включаемой информации для создания логически связного и понятного представления. Система использует алгоритмы структурирования для организации контекста в логические блоки.

**Тематическая группировка** организует релевантную информацию по темам, создавая структурированное представление различных аспектов взаимодействия. Это помогает LLM лучше понимать связи между различными элементами контекста и генерировать более связные ответы.

**Хронологическая организация** упорядочивает события и информацию по времени, когда это важно для понимания развития ситуации или отношений. Хронологический порядок помогает отслеживать изменения и тренды в поведении или обстоятельствах.

**Причинно-следственные связи** выделяются и структурируются для помощи в понимании логики развития событий и принятия решений. Система отслеживает связи между действиями, реакциями, изменениями состояния для создания более глубокого понимания контекста.

**Разрешение противоречий** обнаруживает и обрабатывает потенциальные противоречия в контексте, предпочитая более новую или более надежную информацию. Система может помечать неопределенности или конфликтующую информацию для соответствующей обработки в промпте.

### 7.3. Стратегии удаления памяти

Эффективное управление жизненным циклом памяти требует продуманных стратегий удаления устаревшей, неактуальной или избыточной информации. Система должна балансировать между сохранением важной исторической информации и оптимизацией использования ресурсов.

#### 7.3.1. Критерии удаления

Решения об удалении информации основаны на комплексном анализе множественных критериев, включающих возраст, важность, частоту использования, эмоциональную значимость, связи с другой информацией. Система использует взвешенную оценку для принятия решений об удалении.

**Временные критерии** устанавливают базовые ограничения на время хранения различных типов информации. Обычные диалоговые сообщения могут храниться несколько месяцев, важные события - годы, а ключевые факты о пользователе - неограниченно долго. Временные ограничения адаптируются под интенсивность взаимодействия и доступные ресурсы.

**Критерии важности** оценивают значимость информации для понимания пользователя и поддержания качества взаимодействия. Информация, критичная для понимания личности пользователя, его предпочтений, важных жизненных событий, получает защиту от удаления. Рутинные обмены сообщениями имеют более низкий приоритет сохранения.

**Критерии использования** учитывают частоту обращения к информации и ее влияние на поведение персонажа. Часто используемая информация получает более высокий приоритет сохранения, в то время как данные, к которым не обращались длительное время, становятся кандидатами на удаление.

**Эмоциональные критерии** защищают эмоционально значимую информацию от преждевременного удаления. События, связанные с сильными эмоциональными реакциями пользователя или персонажа, важные личные откровения, моменты близости или конфликта сохраняются дольше обычного.

#### 7.3.2. Градуальное удаление

Процесс удаления памяти происходит постепенно, через несколько стадий деградации информации. Это позволяет сохранить возможность восстановления важной информации и обеспечивает плавный переход от детального хранения к полному удалению.

**Стадия архивации** перемещает старую информацию из активной памяти в архивное хранилище с ограниченным доступом. Архивированная информация не используется для формирования контекста в обычных ситуациях, но может быть восстановлена при специальных запросах или обнаружении высокой релевантности.

**Стадия сжатия** применяет агрессивные алгоритмы сжатия к архивированной информации, сохраняя только ключевые смыслы и факты. Детальные формулировки, метаданные, контекстная информация удаляются, оставляя компактные семантические представления.

**Стадия обобщения** заменяет конкретные события и факты обобщенными паттернами и статистиками. Например, множество обсуждений работы может быть заменено обобщенной информацией о профессиональных интересах и проблемах пользователя.

**Стадия удаления** окончательно удаляет информацию из системы после исчерпания всех возможностей сжатия и обобщения. Удаление происходит только после тщательной проверки отсутствия связей с важной информацией и подтверждения низкой вероятности будущего использования.

#### 7.3.3. Защищенная память

Некоторые типы информации получают специальную защиту от удаления и сохраняются в течение всего жизненного цикла персонажа. Защищенная память включает критически важную информацию для поддержания идентичности персонажа и качества взаимодействия.

**Ключевые факты о пользователе** включают базовую демографическую информацию, важные жизненные события, устойчивые предпочтения и характеристики. Эта информация формирует основу понимания пользователя персонажем и защищается от любых форм удаления.

**Значимые события отношений** охватывают важные моменты в развитии взаимодействия между персонажем и пользователем: первая встреча, моменты близости, конфликты и их разрешение, достижения и празднования. Эти события определяют историю отношений и сохраняются в детальном виде.

**Эмоциональные вехи** включают моменты сильных эмоциональных переживаний, важные откровения, периоды поддержки или кризиса. Эмоциональная память критически важна для поддержания глубины и аутентичности отношений.

**Обучающая информация** содержит выводы о предпочтениях пользователя, эффективных стратегиях взаимодействия, успешных и неуспешных подходах. Эта информация используется для постоянного улучшения качества взаимодействия и защищается как ценный опыт.

#### 7.3.4. Восстановление удаленной информации

Система поддерживает механизмы восстановления случайно или преждевременно удаленной информации через резервные копии, логи операций, связанные данные. Восстановление возможно в течение ограниченного времени после удаления.

**Резервное копирование** создает периодические снимки состояния памяти, позволяющие восстановить информацию на определенные моменты времени. Резервные копии хранятся в сжатом виде и автоматически удаляются через определенные интервалы.

**Логирование операций** записывает все операции удаления с достаточной детализацией для возможного восстановления. Логи включают идентификаторы удаленной информации, причины удаления, временные метки, связанные данные.

**Восстановление по связям** использует связи между различными элементами памяти для реконструкции удаленной информации. Если удаленная информация упоминается в сохранившихся записях, система может частично восстановить ее содержание.

**Ручное восстановление** позволяет администраторам или в исключительных случаях пользователям запросить восстановление конкретной информации. Такие запросы обрабатываются индивидуально с учетом технических возможностей и политик конфиденциальности.

---


## 8. Этические аспекты и безопасность

### 8.1. Принципы этичного ИИ

Разработка системы интеллектуальных персонажей основывается на фундаментальных принципах этического искусственного интеллекта, обеспечивающих безопасное, справедливое и ответственное взаимодействие с пользователями. Система должна способствовать благополучию пользователей, уважать их автономию и достоинство, обеспечивать прозрачность и подотчетность в своей работе.

#### 8.1.1. Принципы обработки данных

Обработка персональных данных должна основываться на принципах минимизации, целевого использования, ограничения хранения, точности, безопасности. Система должна собирать только необходимые данные и использовать их исключительно для необходимых целей.

**Минимизация данных** означает сбор только той информации, которая необходима для функционирования персонажа и обеспечения качественного взаимодействия. Система должна избегать избыточного сбора данных и регулярно пересматривать необходимость различных типов информации.

#### 8.1.2. Техническая защита данных

Система должна использовать современные технологии шифрования, контроля доступа, мониторинга безопасности для защиты пользовательских данных от несанкционированного доступа, утечек, злоупотреблений.

**Контроль доступа** обеспечивает, что только авторизованные системы и персонал имеют доступ к пользовательским данным. Система должна использовать принципы минимальных привилегий и разделения обязанностей для ограничения доступа к данным.

**Мониторинг безопасности** включает непрерывное отслеживание попыток несанкционированного доступа, аномальной активности, потенциальных угроз безопасности. Система должна автоматически обнаруживать и реагировать на инциденты безопасности.

**Резервное копирование и восстановление** обеспечивает защиту данных от потери при технических сбоях или атаках. Резервные копии должны быть зашифрованы и храниться в безопасных местах с ограниченным доступом.

#### 8.1.3. Права пользователей

Пользователи должны иметь полный контроль над своими данными, включая право доступа, исправления, удаления, переносимости. Система должна предоставлять удобные инструменты для реализации этих прав.

**Право на удаление** (право на забвение) позволяет пользователям требовать удаления их персональных данных при определенных обстоятельствах. Система должна обеспечивать полное и безвозвратное удаление данных по запросу пользователя, с сохранением в течении 30ти дней и уведомлением об этом пользователя.

### 8.2. Предотвращение злоупотреблений

Система должна включать комплексные механизмы предотвращения, обнаружения и реагирования на различные формы злоупотреблений, включая манипуляции, мошенничество, вредоносное использование персонажей.

#### 8.2.1. Обнаружение аномального поведения

Система мониторинга должна отслеживать паттерны взаимодействия для выявления потенциально вредоносной или неэтичной активности. Алгоритмы машинного обучения должны обучаться распознавать признаки злоупотреблений.

**Мониторинг взаимодействий** анализирует частоту, продолжительность, содержание диалогов для выявления аномальных паттернов. Чрезмерно интенсивное использование, попытки извлечения конфиденциальной информации, агрессивное поведение должны автоматически обнаруживаться.

**Кросс-платформенный анализ** сопоставляет активность пользователей на различных платформах и сервисах для выявления координированных атак или злоупотреблений. Это помогает обнаруживать сложные схемы мошенничества.

#### 8.2.2. Защита от манипуляций

Персонажи должны быть защищены от попыток манипулирования их поведением или извлечения неавторизованной информации. Система должна включать механизмы обнаружения и противодействия различным формам социальной инженерии.

**Ограничения на раскрытие информации** предотвращают случайное или преднамеренное раскрытие конфиденциальной информации о других пользователях, системе, алгоритмах. Персонажи должны быть обучены защищать приватность и коммерческие секреты.

**Устойчивость к джейлбрейкингу** защищает от попыток обойти встроенные ограничения и заставить персонажа вести себя неэтично или небезопасно. Система должна включать множественные уровни защиты от таких атак.

#### 8.2.3. Модерация контента

Система должна включать эффективные механизмы модерации для предотвращения распространения вредоносного, неэтичного или незаконного контента через взаимодействие с персонажами.

**Автоматическая фильтрация** использует алгоритмы машинного обучения для обнаружения и блокировки неприемлемого контента в реальном времени. Фильтры должны покрывать различные категории вредоносного контента: насилие, дискриминацию, дезинформацию, незаконную активность.

**Градуированные санкции** предусматривают различные уровни ответных мер в зависимости от серьезности нарушения: предупреждения, временные ограничения, постоянные блокировки. Санкции должны быть пропорциональными и справедливыми.

---


## 9. Этика и механизмы влияния

### 9.1. Техники влияния и условия активации

Техники влияния используются для управления поведением персонажа в зависимости от ситуации и целей взаимодействия. Система должна включать механизмы активации этих техник на основе определенных условий и контекста диалога.

#### 9.1.1. Техники влияния

Техники влияния включают различные методы воздействия на персонажа, такие как убеждение, эмоциональное воздействие, социальное давление, когнитивные искажения и другие. Система должна поддерживать широкий спектр техник для различных ситуаций и целей.

**Убеждение** используется для изменения убеждений и представлений персонажа о мире. Это может включать использование логических аргументов, эмоциональных привязок, социальных доказательств и других методов.

**Эмоциональное воздействие** направлено на изменение эмоционального состояния персонажа. Это может включать использование позитивных или негативных эмоций, создание эмоциональных контрастов, использование метафор и других методов.

**Социальное давление** используется для изменения поведенческих паттернов персонажа на основе социальных норм и ожиданий. Это может включать использование социальных доказательств, примера, социальных сравнений и других методов.

**Когнитивные искажения** используются для изменения мышления персонажа, его представлений о мире и самооценки. Это может включать использование предвзятых представлений, неполных данных, ложных аналогий и других методов.

#### 9.1.2. Условия активации

Условия активации определяют моменты, когда персонаж будет более подвержен воздействию тех или иных техник влияния. Система должна учитывать различные факторы, такие как эмоциональное состояние, текущая ситуация, цели взаимодействия и другие.

**Эмоциональные состояния** могут включать фрустрацию, энтузиазм, меланхолию, тревожность и другие эмоциональные состояния, которые могут изменяться в зависимости от ситуации и времени.

**Текущие ситуации** могут включать конфликты, стресс, изменения в отношениях, новые задачи и другие ситуации, которые могут повлиять на поведение персонажа.

**Цели взаимодействия** могут включать достижение определенных результатов, создание определенного образа взаимодействия, поддержание определенного имиджа и другие цели.

### 9.2. Ограничения и этические проверки

Система должна учитывать этические ограничения при использовании тех или иных техник влияния. Это может включать анализ возможных негативных последствий, рассмотрение альтернативных подходов, соблюдение этических стандартов и другие аспекты.

#### 9.2.1. Анализ возможных негативных последствий

Система должна оценивать возможные негативные последствия использования тех или иных техник влияния. Это может включать анализ влияния на психическое здоровье, социальные отношения, моральные аспекты и другие аспекты.

#### 9.2.2. Рассмотрение альтернативных подходов

Система должна рассматривать альтернативные подходы к решению проблем, которые могут быть более этичными или менее разрушительными для персонажа. Это может включать использование ненасильственных методов, создание безопасных условий для персонажа и другие подходы.

#### 9.2.3. Соблюдение этических стандартов

Система должна соблюдать этические стандарты при использовании тех или иных техник влияния. Это может включать анализ этических аспектов, соблюдение этических норм, использование этически обоснованных методов и другие аспекты.

### 9.3. Логирование и аудит

Система должна включать механизмы логирования и аудита для контроля использования тех или иных техник влияния. Это может включать ведение журнала использования техник, анализ частоты их применения, оценку эффективности и другие аспекты.

#### 9.3.1. Ведение журнала использования техник

Система должна вести журнал использования техник влияния, включая информацию о времени, контексте, результатах и другие аспекты. Это позволяет отслеживать частоту и эффективность использования тех или иных техник.

#### 9.3.2. Анализ частоты применения техник

Система должна оценивать эффективность использования тех или иных техник влияния для достижения поставленных целей и создания желаемого образа взаимодействия.

---


## 10. Финальный этап: Консолидация ТЗ

### 10.1. Объединение всех частей

В ходе консолидации технического задания все отдельные части объединяются в единую структуру, которая отражает все требования и аспекты разработки системы. Это позволяет получить четкое представление о том, что должна делать система, как она должна работать и какие технологии и компоненты необходимы для ее реализации.

### 10.2. Глобальная проверка и оценка уверенности

После объединения всех частей технического задания проводится глобальная проверка и оценка уверенности в том, что все требования и аспекты разработки системы учтены и реализованы. Это позволяет убедиться в том, что система соответствует требованиям заказчика и будет эффективной в решении поставленных задач.

---

## 11. Система тестирования

### 11.1. Структура каталогов и уровней тестов

**Каталоги тестов:**
- `test/auth`, `test/character`, `test/cache`, `test/dialog`, `test/llm`, `test/telegram`, `test/monitoring`, `test/utils` и другие — отражают доменную структуру `src/`.
- `test/integration` — сквозные интеграционные сценарии межмодульного взаимодействия.
- `test/unit` — модульные тесты небольших функций и сервисов (по умолчанию `.test.ts`).
- `test/e2e` — сквозные пользовательские сценарии (файлы `.e2e.test.ts`).

**Соглашения об именовании:**
- `*.test.ts` — юнит-тесты.
- `*.integration.test.ts` — интеграционные.
- `*.e2e.test.ts` — end-to-end.

### 11.2. Инфраструктура тестирования

- Библиотека `lib/tester` обеспечивает:
  - `FixtureManager` для подготовки/очистки данных;
  - `mocks/` с реализациями сервисов (ConfigService, EventEmitter и др.);
  - `templates/` с шаблонами типичных интеграционных тестов;
  - `utils/` для оптимизации скорости прогона.
- Настройка окружения:
  - `test/setup.ts` — глобальная конфигурация Jest;
  - `test/setup-integration.ts` — подключение к контейнеризованной PostgreSQL из `docker-compose.test.yml`.

### 11.3. Метрики покрытия и CI

- Целевые значения: `coverage` и `coverageFullWork` — 100 % (см. `.progress.json`).
- Основные скрипты:
  - `yarn test:unit`, `yarn test:integration`, `yarn test:e2e`, `yarn test:all`.
- В GitHub Actions выполняется проверка метрик; при падении покрытия ниже 95 % workflow помечается как failed.
- Отчёты покрытия формата lcov публикуются в PR через Codecov/Actions.

---

### 2.2. Взаимодействие между сервисами

#### 2.2.1. Паттерн внедрения зависимостей (Dependency Injection)
NestJS-контейнер IoC автоматически внедряет зависимости по интерфейсам `I*`. Это обеспечивает слабую связанность, удобное мокирование сервисов в тестах (`CacheService` → `CacheServiceMock`) и гибкость замены реализаций без изменения кода потребителей.

#### 2.2.2. Событийно-ориентированная архитектура
Система публикует события через `EventEmitter2`. Ключевые события: `UserMessageReceived`, `MemoryCompressed`, `CharacterStateChanged`, `ManipulationTechniqueActivated`. Подписчики из разных модулей реагируют асинхронно, что снижает связность и повышает масштабируемость.

#### 2.2.3. Синхронное и асинхронное взаимодействие
Быстрые операции выполняются синхронно (валидация, чтение кэша). Долгие задачи (LLM-запросы, резервное копирование, сжатие памяти) ставятся в `MessageQueueModule` (Redis + BullMQ) с приоритетами и ретраями. Это гарантирует стабильную реакцию API и распределяет нагрузку.

#### 2.2.4. Интерфейсы и контракты
Каждый сервис публикует контракт через интерфейс (`ICacheService`, `ILLMService`). Тесты используют эти контракты для моков; реализация может быть заменена (например, `InMemoryCacheService` ⇄ `RedisCacheService`) без изменения бизнес-логики.

---

#### 3.1.10. Сущность User (Пользователь)
Управляет базовой учетной записью. Поля: `user_id` (UUID, PK), `email`, `password_hash`, `role`, `created_at`, `is_active`. Индекс на `email` уникальный.

#### 3.1.11. Сущность ApiKey (AccessKey)
Хранит API-ключи. Поля: `key_id` (UUID), `user_id` FK → User, `token` (varchar 64), `scopes` (text[]), `expires_at`, `revoked`, `created_at`.

#### 3.1.12. Сущность MessageQueueEntry (Очередь сообщений)
Отражает задания в `MessageQueueModule`. Поля: `msg_id` (UUID), `payload` (JSONB), `status` (enum QUEUED|PROCESSING|FAILED|DONE), `priority`, `retries`, `created_at`, `processed_at`.

#### 3.1.13. Сущность CacheEntry (Запись кэша)
Для статистики кэш-слоя. Поля: `cache_key` (varchar), `value` (JSONB), `ttl`, `created_at`. Индекс по `cache_key`.

#### 3.1.14. Сущность PromptTemplate (Шаблон промпта)
Версионируемые шаблоны LLM. Поля: `template_id`, `name`, `version`, `engine`, `content` (text), `created_at`, `updated_at`.

#### 3.1.15. Сущность ValidationRule (Правило валидации)
Служебная таблица для динамических правил. Поля: `rule_id`, `name`, `description`, `definition` (JSON), `created_at`, `updated_at`.
