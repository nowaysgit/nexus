{
  "integration_test": {
    "description": "Интеграционные тесты проверяют взаимодействие между различными частями системы, включая базу данных, сервисы и контроллеры.",
    "structure": {
      "imports": "import { Tester, createTestSuite, createTest } from '../../lib/tester';\nimport { FixtureManager } from '../../lib/tester/fixtures/fixture-manager';",
      "describe_block": "createTestSuite('Интеграционный тест для [Название модуля/сервиса]', () => { ... });",
      "setup": {
        "beforeAll": "Инициализация Tester и FixtureManager, запуск тестового окружения с типом конфигурации 'integration' через tester.init('integration').",
        "afterAll": "Закрытие тестового окружения через tester.close().",
        "beforeEach": "Очистка базы данных перед каждым тестом через fixtureManager.cleanDatabase()."
      },
      "test_case": {
        "format": "createTest({ name: 'Тест [описание сценария]', configType: 'integration' }, async (context) => { ... });",
        "preparation": "Подготовка данных через fixtureManager с созданием необходимых сущностей (например, fixtureManager.createUser(), fixtureManager.createCharacter()).",
        "action": "Выполнение действия (например, вызов API или метода сервиса через context).",
        "assertion": "Проверка результата действия через expect().",
        "db_check": "Проверка изменений в базе данных через методы fixtureManager.getRepository() или fixtureManager.getTestData()."
      }
    },
    "file_naming": ".integration.test.ts"
  },
  "unit_test": {
    "description": "Юнит-тесты фокусируются на проверке отдельных методов или функций, но могут использовать базу данных.",
    "structure": {
      "imports": "import { Tester, createTestSuite, createTest } from '../../lib/tester';\nimport { FixtureManager } from '../../lib/tester/fixtures/fixture-manager';\nimport { [НазваниеСервиса] } from 'путь/к/сервису';",
      "describe_block": "createTestSuite('Юнит-тест для [Название сервиса/метода]', () => { ... });",
      "setup": {
        "beforeAll": "Инициализация Tester, FixtureManager и тестируемого сервиса, запуск тестового окружения с типом конфигурации 'database' или другой через tester.init('database').",
        "afterAll": "Закрытие тестового окружения через tester.close().",
        "beforeEach": "Очистка базы данных перед каждым тестом через fixtureManager.cleanDatabase()."
      },
      "test_case": {
        "format": "createTest({ name: 'Тест [описание метода/функции]', configType: 'database' }, async (context) => { ... });",
        "preparation": "Подготовка данных через fixtureManager с созданием необходимых сущностей (например, fixtureManager.createUser(), fixtureManager.createCharacter()).",
        "action": "Выполнение метода сервиса через context.get([НазваниеСервиса]).",
        "assertion": "Проверка результата метода через expect().",
        "db_check": "Проверка изменений в базе данных через методы fixtureManager.getRepository() или fixtureManager.getTestData()."
      }
    },
    "file_naming": ".test.ts"
  },
  "general_rules": {
    "abstraction": "Использовать абстракцию над Jest из '../../lib/tester/'.",
    "db_cleanup": "Перед каждым тестом полностью очищать тестовую БД через fixtureManager.cleanDatabase().",
    "fixtures": "Создавать фикстуры через методы FixtureManager (например, createUser(), createCharacter()) для заполнения БД тестовыми данными.",
    "assertions": "Тесты должны проверять изменения в БД, быть надежными и иметь понятные проверки через expect().",
    "documentation": "Каждый тест должен быть четко описан, чтобы было понятно, что именно проверяется.",
    "extension": "Расширять абстракцию тестера при необходимости, сохраняя лаконичность тестовых файлов.",
    "interface": "Каждый тест оформлять с использованием createTestSuite и createTest, предоставляемыми Tester, для поддержания строгого и понятного интерфейса тестирования."
  },
  "standardTestFileStructure": {
    "imports": [
      "Импортировать Tester, createTestSuite, createTest, TestConfigType из lib/tester",
      "Импортировать FixtureManager из lib/tester/fixtures",
      "Импортировать тестируемый сервис и зависимости"
    ],
    "suiteSetup": [
      "Использовать createTestSuite для создания тестового набора",
      "Внутри тестового набора объявить переменные tester, fixtureManager, dataSource",
      "Реализовать beforeAll с инициализацией tester = Tester.getInstance(), dataSource = await tester.setupTestEnvironment(TestConfigType.DATABASE), fixtureManager = new FixtureManager(dataSource)",
      "Реализовать afterAll с вызовом await tester.forceCleanup()",
      "Реализовать beforeEach с вызовом await fixtureManager.cleanDatabase()"
    ],
    "testCases": [
      "Использовать createTest для создания тестов",
      "Использовать context.get<ServiceName>(ServiceName) для получения сервиса из контекста",
      "Использовать fixtureManager для создания тестовых данных",
      "Использовать jest.mock или jest.fn для моков при необходимости"
    ]
  },
  "testFixtureManager": {
    "methods": [
      {
        "name": "createUser",
        "description": "Создает тестового пользователя",
        "params": "частичный объект User с поддержкой как string, так и number для id",
        "returns": "Promise<User>"
      },
      {
        "name": "createCharacter",
        "description": "Создает тестового персонажа",
        "params": "частичный объект Character с обязательным указанием personality.musicTaste при необходимости",
        "returns": "Promise<Character>"
      },
      {
        "name": "createDialog",
        "description": "Создает тестовый диалог",
        "params": "частичный объект Dialog",
        "returns": "Promise<Dialog>"
      },
      {
        "name": "createMessage",
        "description": "Создает тестовое сообщение",
        "params": "частичный объект Message",
        "returns": "Promise<Message>"
      },
      {
        "name": "createNeed",
        "description": "Создает тестовую потребность",
        "params": "частичный объект Need с полем currentValue вместо устаревшего currentLevel",
        "returns": "Promise<Need>"
      },
      {
        "name": "createMotivation",
        "description": "Создает тестовую мотивацию",
        "params": "частичный объект CharacterMotivation с полем intensity для указания уровня мотивации",
        "returns": "Promise<CharacterMotivation>"
      },
      {
        "name": "createEmotionalState",
        "description": "Создает тестовое эмоциональное состояние",
        "params": "объект с эмоциональным состоянием персонажа и опциональным указанием characterId",
        "returns": "Promise<any>"
      },
      {
        "name": "createAction",
        "description": "Создает тестовое действие персонажа",
        "params": "частичный объект Action с опциональным указанием character или characterId",
        "returns": "Promise<Action>"
      },
      {
        "name": "createTechniqueExecution",
        "description": "Создает тестовое исполнение манипулятивной техники",
        "params": "частичный объект TechniqueExecution с обязательным преобразованием characterId и userId в Number",
        "returns": "Promise<TechniqueExecution>"
      },
      {
        "name": "createUserManipulationProfile",
        "description": "Создает тестовый профиль манипуляции пользователя",
        "params": "частичный объект UserManipulationProfile с обязательным преобразованием userId и characterId в Number",
        "returns": "Promise<UserManipulationProfile>"
      },
      {
        "name": "createStoryPlan",
        "description": "Создает тестовый план развития сюжета",
        "params": "частичный объект StoryPlan с опциональным указанием characterId",
        "returns": "Promise<StoryPlan>"
      },
      {
        "name": "createStoryMilestone",
        "description": "Создает тестовый этап сюжетной линии",
        "params": "частичный объект StoryMilestone с опциональным указанием storyPlanId и characterId",
        "returns": "Promise<StoryMilestone>"
      },
      {
        "name": "cleanDatabase",
        "description": "Очищает тестовую базу данных",
        "params": "нет",
        "returns": "Promise<void>"
      },
      {
        "name": "getRepository",
        "description": "Получает репозиторий для указанной сущности",
        "params": "класс сущности (Entity)",
        "returns": "Repository<Entity>"
      },
      {
        "name": "getTestData",
        "description": "Получает данные тестов по ID",
        "params": "ID тестовых данных",
        "returns": "ITestData"
      },
      {
        "name": "ensureIdFormat",
        "description": "Обеспечивает совместимость ID между строковым (UUID) и числовым форматом",
        "params": "id: string | number, targetType: 'string' | 'number'",
        "returns": "string | number в требуемом формате"
      },
      {
        "name": "numericToUuid",
        "description": "Преобразует числовой ID в UUID строку",
        "params": "numericId: number | string",
        "returns": "UUID строка"
      },
      {
        "name": "uuidToNumeric",
        "description": "Преобразует UUID в числовой ID",
        "params": "uuid: string",
        "returns": "number | null"
      }
    ]
  },
  "mocks": {
    "location": "lib/tester/mocks",
    "description": "Все моки для тестов централизованы в директории 'lib/tester/mocks'. Это обеспечивает единое место для управления тестовыми моками и упрощает их использование в различных тестах.",
    "available_mocks": [
      {
        "file": "log.service.mock.ts",
        "description": "Мок для LogService."
      },
      {
        "file": "rollbar.service.mock.ts",
        "description": "Мок для RollbarService."
      },
      {
        "file": "config.service.mock.ts",
        "description": "Мок для ConfigService."
      },
      {
        "file": "llama-provider.mock.ts",
        "description": "Мок для LlamaProvider."
      },
      {
        "file": "mock-telegram.module.ts",
        "description": "Модуль с моками для тестирования Telegram."
      },
      {
        "file": "telegraf-token.provider.ts",
        "description": "Мок провайдера токена для Telegraf."
      },
      {
        "file": "user-service.mock.ts",
        "description": "Мок для UserService."
      },
      {
        "file": "telegram-service.mock.ts",
        "description": "Мок для TelegramService."
      },
      {
        "file": "needs-service.mock.ts",
        "description": "Мок для NeedsService."
      },
      {
        "file": "memory-service.mock.ts",
        "description": "Мок для MemoryService."
      },
      {
        "file": "event-emitter.mock.ts",
        "description": "Мок для EventEmitter."
      }
    ]
  }
}